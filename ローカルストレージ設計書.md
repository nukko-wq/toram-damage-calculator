# ローカルストレージ設計書

## 1. 概要

**目的**: トーラムオンライン ダメージ計算ツールにおけるローカルストレージを活用したデータ永続化とセーブデータ管理システムの設計

**対象データ**:
- **セーブデータ**：計算機の全入力状態（キャラステータス、装備選択、クリスタル選択等）
- **プリセットデータ（ローカル管理）**：システム提供データをローカルストレージで管理
- **ユーザーカスタム装備**：全セーブデータで共有される独自装備データ
- **ユーザーカスタムクリスタル**：全セーブデータで共有される独自クリスタルデータ
- **ユーザーカスタム敵情報**：全セーブデータで共有される独自敵情報データ

**プリセットデータ更新の課題**:
システム側でプリセットデータが更新された場合（新敵情報追加、装備追加等）、既存ユーザーが新しいデータにアクセスできるようにする必要がある。

**解決方法：バージョン管理システム**:
- プリセットデータにバージョン情報を付与
- アプリ起動時にバージョンチェック
- 新バージョン検出時に差分更新実行
- ユーザー編集済みデータの保護

**データ分離の概念**:
- セーブデータは「どの装備・クリスタル・敵情報を選択したか」の参照情報のみ保存
- カスタム装備・クリスタル・敵情報は独立したデータとして管理
- 全セーブデータから同じカスタムデータプールを参照可能

**分離設計のメリット**:
- データ重複の排除（同じカスタムアイテムを複数セーブデータで使用可能）
- ストレージ容量の効率化
- カスタムデータの一元管理
- セーブデータ間でのカスタムアイテム共有

## 1.1 プリセットデータ更新システム

### 1.1.1 バージョン管理の仕組み

**プリセットデータバージョン情報**:
```json
{
  "version": "1.2.0",
  "releaseDate": "2025-01-17",
  "equipments": {
    "version": "1.1.0",
    "checksum": "abc123def456"
  },
  "crystals": {
    "version": "1.0.1", 
    "checksum": "def456ghi789"
  },
  "enemies": {
    "version": "1.2.0",
    "checksum": "ghi789jkl012"
  }
}
```

**バージョンチェック方式**:
- 各プリセットデータファイル（装備、クリスタル、敵情報）に個別バージョン
- チェックサムによるデータ整合性確認
- セマンティックバージョニング（major.minor.patch）

### 1.1.2 差分更新の仕組み

**更新対象の判定**:
```typescript
interface UpdateCheckResult {
  needsUpdate: boolean
  equipmentsUpdate: boolean
  crystalsUpdate: boolean
  enemiesUpdate: boolean
  oldVersion: string
  newVersion: string
}
```

**差分更新の原則**:
1. **新規追加のみ**: 既存アイテムは変更しない
2. **ユーザー編集保護**: 編集済みプリセットデータは上書きしない
3. **ID衝突回避**: 新アイテムのIDが既存と重複する場合はスキップ
4. **ロールバック不可**: 一度更新したら元には戻せない

**更新処理フロー**:
```
バージョンチェック → 新規アイテム抽出 → ID衝突チェック → ユーザー編集チェック → 安全な新規アイテムのみ追加 → ローカルバージョン更新
```

### 1.1.3 データ保護メカニズム

**編集済みデータの識別**:
```typescript
interface LocalStoragePresetItem {
  id: string
  name: string
  // ... その他のプロパティ
  isPreset: true
  isFavorite: boolean          // ユーザーが変更可能
  isModified: boolean          // ユーザーが編集したかどうか
  modifiedAt?: string          // 最終編集日時
  originalChecksum?: string    // 元データのチェックサム
  createdAt: string
  updatedAt: string
}
```

**保護されるケース**:
- `isFavorite`がtrueに変更されたアイテム
- プロパティ値が編集されたアイテム
- 名前が変更されたアイテム
- `isModified: true`が設定されたアイテム

**更新されるケース**:
- 全く手を加えていないプリセットデータのアイテム
- システム側で完全に新規追加されたアイテム

### 1.1.4 ユーザー体験

**起動時の更新体験**:
```
アプリ起動 → "新しいデータを確認中..." → "新しい敵情報が3件追加されました" → 通常のアプリ画面
```

**更新通知の例**:
- 「新しい敵情報が追加されました（3件）」
- 「新しい装備が追加されました（5件）」  
- 「新しいクリスタルが追加されました（2件）」

**更新エラー時の対応**:
- ネットワークエラー：既存データで継続、次回起動時に再試行
- データ破損エラー：エラーログ記録、既存データで継続
- 容量不足エラー：容量確保の提案表示

### 1.1.5 差分更新の実装例

**新規アイテム抽出処理**:
```typescript
async function extractNewItems<T extends { id: string }>(
  currentItems: T[],
  latestItems: T[]
): Promise<T[]> {
  const currentIds = new Set(currentItems.map(item => item.id))
  return latestItems.filter(item => !currentIds.has(item.id))
}

// 使用例：敵情報の新規追加分を抽出
const newEnemies = await extractNewItems(
  getLocalPresetEnemies(),
  await getLatestPresetEnemies()
)
```

**安全な追加処理**:
```typescript
async function safelyAddNewItems<T extends LocalStoragePresetItem>(
  storageKey: string,
  newItems: T[]
): Promise<number> {
  const existingItems = getFromLocalStorage<T[]>(storageKey) || []
  const existingIds = new Set(existingItems.map(item => item.id))
  
  // ID衝突チェック
  const safeItems = newItems.filter(item => !existingIds.has(item.id))
  
  // 新規アイテムにメタデータ追加
  const itemsWithMeta = safeItems.map(item => ({
    ...item,
    isPreset: true,
    isFavorite: false,
    isModified: false,
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  }))
  
  // ローカルストレージに追加
  const updatedItems = [...existingItems, ...itemsWithMeta]
  saveToLocalStorage(storageKey, updatedItems)
  
  return safeItems.length
}
```

## 2. セーブデータ管理システム

### 2.1 基本コンセプト

**デフォルトセーブデータ（メインデータ）**:
- システム起動時に自動的に使用される「メインデータ」
- **初回アクセス時に自動作成される**
- 削除不可、名前変更不可、常に存在する
- 全ての計算機能の基準となるデータ

**ユーザーセーブデータ**:
- ユーザーが任意で作成・管理できるセーブデータ
- 名前付きで保存、複数作成可能
- 作成、読み込み、更新、削除、並び替え、名前変更が可能

### 2.2 アプリ起動時の動作

**起動時フロー**（初回・既存ユーザー共通）:
```
アプリ起動 → ストレージチェック → プリセットデータバージョンチェック → [バージョン更新有り]プリセットデータ差分更新 → メインデータ存在確認 → [存在しない場合]メインデータ作成 → メインデータを現在のセーブデータに設定 → アプリ開始
```

**初期化処理**:
1. **バージョンチェック・プリセットデータ更新**:
   - ローカルストレージの現在バージョンを取得
   - システム側の最新バージョンと比較
   - 新バージョンが存在する場合、差分更新を実行
   - 初回アクセスの場合、プリセットデータの全コピーを実行
2. LocalStorageの`SAVE_DATA_LIST`キーをチェック
3. メインデータ（id: "default"）の存在確認
4. 存在しない場合、デフォルト値でメインデータを作成
5. `CURRENT_SAVE_ID`を"default"に設定
6. 各フォームにデフォルト値を適用

**メインデータのデフォルト値**:
```typescript
const DEFAULT_MAIN_DATA: DefaultSaveData = {
  id: "default",
  name: "メインデータ",
  isDefault: true,
  createdAt: new Date().toISOString(),
  updatedAt: new Date().toISOString(),
  order: 0,
  data: {
    baseStats: getDefaultBaseStats(),      // レベル1、全ステータス最小値
    weapons: getDefaultWeapons(),          // 武器未選択状態
    crystals: getDefaultCrystals(),        // クリスタル未選択状態
    equipments: getDefaultEquipments(),    // 装備未選択状態
    food: getDefaultFood(),               // 料理未選択状態（全スロット「なし」）
    enemy: getDefaultEnemy(),              // 敵の基本設定
    buffSkills: getDefaultBuffSkills()     // バフスキル未選択状態（全スキルOFF）
  }
}
```

**初期化関数の実装例**:
```typescript
export async function initializeStorage(): Promise<void> {
  try {
    // バージョンチェック・プリセットデータ更新
    await checkAndUpdatePresetData()
    
    // メインデータの確保
    await ensureDefaultSaveData()
    
    // 現在のセーブデータ設定
    const currentSaveId = localStorage.getItem(STORAGE_KEYS.CURRENT_SAVE_ID)
    if (!currentSaveId) {
      localStorage.setItem(STORAGE_KEYS.CURRENT_SAVE_ID, "default")
    }
    
    // データ整合性チェック
    await validateStorageIntegrity()
  } catch (error) {
    console.error('ストレージ初期化エラー:', error)
    // フォールバック処理
    await resetToDefault()
  }
}

// プリセットデータチェック・更新関数
async function checkAndUpdatePresetData(): Promise<void> {
  // 現在のローカルバージョンを取得
  const localVersion = getLocalPresetVersion()
  
  // システム側の最新バージョンを取得
  const latestVersion = await getLatestPresetVersion()
  
  // 初回アクセス（ローカルバージョンなし）
  if (!localVersion) {
    await initialCopyPresetData()
    await saveLocalPresetVersion(latestVersion)
    return
  }
  
  // バージョン比較
  const updateCheck = compareVersions(localVersion, latestVersion)
  
  if (updateCheck.needsUpdate) {
    await performDifferentialUpdate(updateCheck)
    await saveLocalPresetVersion(latestVersion)
  }
}

// 初回プリセットデータコピー
async function initialCopyPresetData(): Promise<void> {
  await copyPresetEquipmentsToLocalStorage()
  await copyPresetCrystalsToLocalStorage()
  await copyPresetEnemiesToLocalStorage()
}

// 差分更新実行
async function performDifferentialUpdate(updateCheck: UpdateCheckResult): Promise<void> {
  if (updateCheck.equipmentsUpdate) {
    await updatePresetEquipments()
  }
  if (updateCheck.crystalsUpdate) {
    await updatePresetCrystals()
  }
  if (updateCheck.enemiesUpdate) {
    await updatePresetEnemies()
  }
}
```

### 2.3 セーブデータの構造

```typescript
interface SaveData {
  id: string                    // 一意識別子
  name: string                  // セーブデータ名
  isDefault: boolean            // デフォルトデータフラグ
  createdAt: string            // 作成日時 (ISO string)
  updatedAt: string            // 更新日時 (ISO string)
  order: number                // 表示順序
  data: {
    baseStats: BaseStatsFormData    // キャラクターベースステータス
    weapons: WeaponFormData         // 武器設定（選択された装備IDの参照）
    crystals: CrystalFormData       // クリスタル設定（選択されたクリスタルIDの参照）
    equipments: EquipmentFormData   // 装備設定（選択された装備IDの参照）
    food: FoodFormData             // 料理設定
    enemy: EnemyFormData           // 敵設定
    buffSkills: BuffSkillFormData   // バフスキル設定（フェーズ2で追加予定）
  }
}

// デフォルトセーブデータ
interface DefaultSaveData extends SaveData {
  id: "default"
  name: "メインデータ"
  isDefault: true
  // 削除不可、名前変更不可
}
```

### 2.4 セーブデータ管理UI

#### 2.4.1 セーブデータ選択・管理画面
```
ヘッダー部分に「セーブデータ」ボタン → セーブデータ管理モーダル
```

**モーダル構成**:
- **タイトル**: 「セーブデータ管理」
- **現在のセーブデータ表示**: 現在使用中のセーブデータ名
- **セーブデータリスト**: 
  - デフォルトデータ（削除不可表示）
  - ユーザー作成データ（並び替え可能）
- **アクションボタン**:
  - 新規作成、読み込み、名前変更、削除、並び替え
  - 現在のデータを保存、キャンセル

#### 2.4.2 セーブデータ操作フロー

**新規作成フロー**:
```
[新規作成] → 名前入力モーダル → 現在の入力内容をコピーして新規セーブデータ作成 → 作成されたデータに切り替え
```

**読み込みフロー**:
```
セーブデータ選択 → [読み込み] → 確認ダイアログ → 選択したデータを読み込み → UI状態更新
```

**名前変更フロー**:
```
セーブデータ選択 → [名前変更] → 名前変更モーダル → 名前更新
```

**削除フロー**:
```
セーブデータ選択 → [削除] → 確認ダイアログ → 削除実行 → リスト更新
```

**並び替えフロー**:
```
[並び替え] → ドラッグ&ドロップ形式の並び替えUI → [保存] → 順序更新
```

## 3. LocalStorage キー設計

### 3.1 キー一覧

```typescript
const STORAGE_KEYS = {
  // セーブデータ（参照情報のみ）
  SAVE_DATA_LIST: 'toram_save_data_list',           // SaveData[]
  CURRENT_SAVE_ID: 'toram_current_save_id',         // string
  
  // プリセットデータ（コピー済み、お気に入り・編集可能）
  PRESET_EQUIPMENTS: 'toram_preset_equipments',     // LocalStorageEquipment[]
  PRESET_CRYSTALS: 'toram_preset_crystals',         // LocalStorageCrystal[]
  PRESET_ENEMIES: 'toram_preset_enemies',           // LocalStorageEnemy[]
  
  // ユーザーカスタムデータ（全セーブデータで共有）
  CUSTOM_EQUIPMENTS: 'toram_custom_equipments',     // UserEquipment[]
  CUSTOM_CRYSTALS: 'toram_custom_crystals',         // UserCrystal[]
  CUSTOM_ENEMIES: 'toram_custom_enemies',           // UserEnemy[]
  
  // バージョン管理
  PRESET_VERSION: 'toram_preset_version',           // PresetVersionInfo
  LAST_UPDATE_CHECK: 'toram_last_update_check',     // string (ISO date)
  
  // アプリケーション設定
  APP_SETTINGS: 'toram_app_settings',               // AppSettings
  STORAGE_VERSION: 'toram_storage_version'          // string
} as const

interface PresetVersionInfo {
  version: string
  releaseDate: string
  equipments: { version: string, checksum: string }
  crystals: { version: string, checksum: string }
  enemies: { version: string, checksum: string }
  lastUpdated: string  // ISO date
}
```

### 3.2 データ参照システム

**参照の仕組み**（統合データアクセス方式）:
```typescript
// セーブデータの装備選択例（簡素化）
interface EquipmentFormData {
  mainWeapon: {
    selectedId: string | null    // 装備ID（プリセット・カスタム統合済み）
  }
  body: {
    selectedId: string | null
  }
  // ... 他の装備スロット
}

// セーブデータの敵情報選択例（簡素化）
interface EnemyFormData {
  selectedId: string | null      // 敵情報ID（プリセット・カスタム統合済み）
  // 手動入力値（プリセット・カスタム選択後のresistCriticalとrequiredHIT調整用）
  manualOverrides?: {
    resistCritical?: number      // 選択した敵情報からの調整値
    requiredHIT?: number         // 選択した敵情報からの調整値
  }
}

// 統合データアクセス（プリセット・カスタムを区別せず取得）
function getEquipmentById(id: string): Equipment | null {
  // プリセット（コピー済み）とカスタムを統合して検索
  const allEquipments = [...getPresetEquipments(), ...getCustomEquipments()]
  return allEquipments.find(eq => eq.id === id) || null
}

function getEnemyById(id: string): Enemy | null {
  // プリセット（コピー済み）とカスタムを統合して検索
  const allEnemies = [...getPresetEnemies(), ...getCustomEnemies()]
  return allEnemies.find(enemy => enemy.id === id) || null
}

function getCrystalById(id: string): Crystal | null {
  // プリセット（コピー済み）とカスタムを統合して検索
  const allCrystals = [...getPresetCrystals(), ...getCustomCrystals()]
  return allCrystals.find(crystal => crystal.id === id) || null
}
```

**データ整合性の保証**:
- セーブデータ読み込み時に参照先の存在確認
- 削除されたプリセット・カスタムデータの参照は自動的にnullに変更
- 破損した参照のエラーハンドリング
- プリセット由来データの編集対応（isPresetフラグによる管理）

### 3.3 データサイズ管理

**容量制限**:
- LocalStorageの一般的な制限: 5-10MB
- 推定データサイズ: 
  - 1セーブデータあたり約5-10KB（参照情報のみ）
  - カスタム装備1個あたり約1-2KB
  - カスタムクリスタル1個あたり約0.5-1KB
  - カスタム敵情報1個あたり約0.3-0.5KB
- 目安: 500-1000個のセーブデータ + 数百個のカスタムアイテムが保存可能

**容量監視**:
```typescript
interface StorageUsage {
  totalSize: number      // 使用中の総サイズ（バイト）
  maxSize: number       // 推定最大サイズ
  usage: number         // 使用率（0-1）
  warning: boolean      // 警告レベル（80%以上）
  critical: boolean     // 危険レベル（95%以上）
}
```

## 4. データ管理API設計

### 4.1 セーブデータ管理

```typescript
// src/utils/saveDataManager.ts

// 初期化・セットアップ
export function initializeStorage(): Promise<void>
export function initializePresetData(): Promise<void>
export function createDefaultSaveData(): Promise<DefaultSaveData>
export function ensureDefaultSaveData(): Promise<DefaultSaveData>

// プリセットデータコピー・更新
export function copyPresetEquipmentsToLocalStorage(): Promise<void>
export function copyPresetCrystalsToLocalStorage(): Promise<void>
export function copyPresetEnemiesToLocalStorage(): Promise<void>

// バージョン管理・差分更新
export function checkAndUpdatePresetData(): Promise<void>
export function getLocalPresetVersion(): PresetVersionInfo | null
export function getLatestPresetVersion(): Promise<PresetVersionInfo>
export function compareVersions(local: PresetVersionInfo, latest: PresetVersionInfo): UpdateCheckResult
export function performDifferentialUpdate(updateCheck: UpdateCheckResult): Promise<void>
export function saveLocalPresetVersion(version: PresetVersionInfo): Promise<void>

// セーブデータ操作
export function createSaveData(name: string, currentData: CalculatorData): Promise<SaveData>
export function loadSaveData(id: string): Promise<SaveData>
export function updateSaveData(id: string, data: Partial<SaveData>): Promise<void>
export function deleteSaveData(id: string): Promise<void>
export function renameSaveData(id: string, newName: string): Promise<void>

// セーブデータリスト管理
export function getAllSaveData(): SaveData[]
export function reorderSaveData(newOrder: string[]): Promise<void>
export function getCurrentSaveData(): SaveData
export function setCurrentSaveData(id: string): Promise<void>

// 手動保存
export function saveCurrentData(data: CalculatorData): Promise<void>


// データ参照・統合（簡素化）
export function resolveEquipmentReference(selectedId: string | null): Equipment | null
export function resolveCrystalReference(selectedId: string | null): Crystal | null
export function resolveEnemyReference(selectedId: string | null): Enemy | null
export function validateSaveDataReferences(saveData: SaveData): boolean

// プリセットデータ管理
export function getPresetEquipments(): LocalStorageEquipment[]
export function getPresetCrystals(): LocalStorageCrystal[]
export function getPresetEnemies(): LocalStorageEnemy[]
export function updatePresetEquipment(id: string, updates: Partial<LocalStorageEquipment>): Promise<void>
export function updatePresetCrystal(id: string, updates: Partial<LocalStorageCrystal>): Promise<void>
export function updatePresetEnemy(id: string, updates: Partial<LocalStorageEnemy>): Promise<void>
```

### 4.2 ユーザーカスタムデータ管理

```typescript
// src/utils/customDataManager.ts

// ユーザー装備管理（userEquipmentManager.tsから移行・統合）
export function createCustomEquipment(equipment: UserEquipment): Promise<void>
export function updateCustomEquipment(id: string, equipment: Partial<UserEquipment>): Promise<void>
export function deleteCustomEquipment(id: string): Promise<void>
export function renameCustomEquipment(id: string, newName: string): Promise<void>
export function getAllCustomEquipments(): UserEquipment[]
export function getCustomEquipmentsByCategory(category: EquipmentCategory): UserEquipment[]
export function getCustomEquipmentById(id: string): UserEquipment | undefined

// ユーザークリスタル管理
export function createCustomCrystal(crystal: UserCrystal): Promise<void>
export function updateCustomCrystal(id: string, crystal: Partial<UserCrystal>): Promise<void>
export function deleteCustomCrystal(id: string): Promise<void>
export function renameCustomCrystal(id: string, newName: string): Promise<void>
export function getAllCustomCrystals(): UserCrystal[]
export function getCustomCrystalsByCategory(category: CrystalCategory): UserCrystal[]
export function getCustomCrystalById(id: string): UserCrystal | undefined

// ユーザー敵情報管理
export function createCustomEnemy(enemy: UserEnemy): Promise<void>
export function updateCustomEnemy(id: string, enemy: Partial<UserEnemy>): Promise<void>
export function deleteCustomEnemy(id: string): Promise<void>
export function renameCustomEnemy(id: string, newName: string): Promise<void>
export function getAllCustomEnemies(): UserEnemy[]
export function getCustomEnemiesByCategory(category: EnemyCategory): UserEnemy[]
export function getCustomEnemyById(id: string): UserEnemy | undefined

// カスタムデータの影響確認（削除前チェック）
export function findSaveDataUsingCustomEquipment(equipmentId: string): SaveData[]
export function findSaveDataUsingCustomCrystal(crystalId: string): SaveData[]
export function findSaveDataUsingCustomEnemy(enemyId: string): SaveData[]
```

### 4.3 ストレージ管理

```typescript
// src/utils/storageManager.ts

// 容量管理
export function getStorageUsage(): StorageUsage
export function cleanupOldData(): Promise<void>
export function validateStorageIntegrity(): Promise<boolean>

// 将来の共有機能のための準備（未実装）
// export function generateShareCode(saveDataId: string): Promise<string>
// export function loadFromShareCode(shareCode: string): Promise<SaveData>

// データ移行
export function migrateStorageVersion(fromVersion: string, toVersion: string): Promise<void>
export function getCurrentStorageVersion(): string
```

## 5. UI/UX設計

### 5.1 セーブデータ管理モーダル

**レイアウト構成**:
```
┌─────────────────────────────────────┐
│ セーブデータ管理                      │
├─────────────────────────────────────┤
│ 現在: メインデータ                    │
├─────────────────────────────────────┤
│ ☰ メインデータ (デフォルト) [読込]    │
│ ☰ キャラクタービルド1    [読込][編集][削除] │
│ ☰ 高レベル用セットアップ  [読込][編集][削除] │
│ ...                                │
├─────────────────────────────────────┤
│ [現在のデータを保存] [新規作成] [キャンセル] │
└─────────────────────────────────────┘
```

**セーブデータリスト項目**:
- ドラッグハンドル（☰）
- セーブデータ名
- 更新日時（相対時間表示）
- アクションボタン（読込、編集、削除）
- デフォルトデータは特別表示（削除ボタンなし）

### 5.2 名前入力モーダル

**新規作成用**:
```
┌─────────────────────────────────────┐
│ 新しいセーブデータを作成               │
├─────────────────────────────────────┤
│ セーブデータ名:                      │
│ [________________] (最大30文字)       │
│                                   │
│ 現在の入力内容をコピーして作成します     │
├─────────────────────────────────────┤
│              [作成] [キャンセル]      │
└─────────────────────────────────────┘
```

**名前変更用**:
```
┌─────────────────────────────────────┐
│ セーブデータ名を変更                  │
├─────────────────────────────────────┤
│ セーブデータ名:                      │
│ [現在の名前__________] (最大30文字)    │
├─────────────────────────────────────┤
│              [変更] [キャンセル]      │
└─────────────────────────────────────┘
```

### 5.3 確認ダイアログ

**削除確認**:
```
セーブデータ「{名前}」を削除しますか？
この操作は取り消せません。

[削除] [キャンセル]
```

**読み込み確認** (未保存の変更がある場合):
```
現在の変更内容が失われます。
セーブデータ「{名前}」を読み込みますか？

[読み込み] [キャンセル]
```

## 6. エラーハンドリング・データ整合性

### 6.1 データ検証

**保存時検証**:
```typescript
interface DataValidation {
  isValid: boolean
  errors: string[]
  warnings: string[]
  brokenReferences: { type: string, id: string }[]  // 破損した参照の一覧
}

export function validateSaveData(data: SaveData): DataValidation
export function validateCustomEquipment(equipment: UserEquipment): DataValidation
export function validateCustomCrystal(crystal: UserCrystal): DataValidation
export function validateCustomEnemy(enemy: UserEnemy): DataValidation
export function validateReferences(saveData: SaveData): DataValidation
```

**整合性チェック**:
- 必須フィールドの存在確認
- データ型の検証
- 値の範囲チェック
- **参照整合性の確認**（重要）:
  - セーブデータが参照するカスタム装備・クリスタル・敵情報の存在確認
  - 削除されたアイテムへの参照を自動修復
  - 循環参照の検出と防止

### 6.2 エラー復旧

**データ破損対応**:
1. 破損データの検出
2. **参照エラーの自動修復**:
   - 削除されたカスタムアイテムへの参照を null に変更
   - セーブデータの機能を維持しつつ、エラーを解決
3. デフォルト値での初期化
4. ユーザーへの通知とオプション提示

**カスタムデータ削除時の影響確認**:
- 削除予定のカスタムアイテムを参照しているセーブデータを検索
- 影響を受けるセーブデータの一覧表示
- 削除前の確認ダイアログでの警告表示

**容量不足対応**:
1. 古いセーブデータの自動削除提案
2. 不要データの削除支援

## 7. セキュリティ・プライバシー

### 7.1 データ保護

**ローカルストレージの特性**:
- ブラウザローカルに保存（外部送信なし）
- ドメイン別分離
- ユーザーによる削除可能

**注意事項**:
- ブラウザのプライベートモードでは永続化されない
- ブラウザデータ削除時に消失する可能性
- 端末間での同期は行われない

### 7.2 将来の共有機能

**コード共有システム（将来実装予定）**:
- セーブデータを短いコードに変換
- コードを入力して他のユーザーの設定を読み込み
- SNSやフォーラムでの設定共有を想定

## 8. パフォーマンス最適化

### 8.1 読み書き最適化

**遅延読み込み**:
- 必要時のみデータを読み込み
- セーブデータリストは概要のみ先行読み込み
- 詳細データは選択時に読み込み

**バッチ処理**:
- 複数の変更をまとめて保存

### 8.2 メモリ管理

**キャッシュ戦略**:
- 現在のセーブデータはメモリにキャッシュ
- 未使用のセーブデータは適時解放
- LRUキャッシュによる効率的なメモリ使用

## 9. 実装優先度

### Phase 1（高優先度）
- **初回アクセス時のメインデータ自動作成**
- **プリセットデータのバージョン管理システム**
- **差分更新機能（新規アイテム追加対応）**
- 基本的なセーブデータ CRUD 操作
- セーブデータ管理UI

### Phase 2（中優先度）
- 並び替え機能
- ストレージ容量監視
- プリセットデータ更新の通知UI

### Phase 3（低優先度）
- 高度な検索・フィルタリング
- データ分析・統計機能
- 手動更新チェック機能
- コード共有システム

## 10. 技術仕様

### 10.1 依存関係

**依存パッケージ**:
- `uuid`: 一意ID生成
- `date-fns`: 日時処理

**既存技術スタックとの統合**:
- Zod: データバリデーション
- React Hook Form: フォーム状態管理
- TypeScript: 型安全性

### 10.2 コンポーネント構成

```
SaveDataManager/
├── SaveDataModal.tsx              // セーブデータ管理モーダル
├── SaveDataList.tsx              // セーブデータリスト
├── SaveDataItem.tsx              // セーブデータ項目
├── SaveDataNameModal.tsx         // 名前入力モーダル
├── SaveDataSortable.tsx          // 並び替え機能
└── hooks/
    ├── useSaveDataManager.ts     // セーブデータ管理ロジック
    └── useStorageMonitor.ts     // ストレージ監視
```

---

## 11. バフスキルデータ構造

### 11.1 BuffSkillFormDataインターフェース

```typescript
interface BuffSkillFormData {
  skills: BuffSkill[]
}

interface BuffSkill {
  id: string                    // スキル識別子
  name: string                  // スキル名
  category: BuffSkillCategory   // スキル系統
  isEnabled: boolean            // オン/オフ状態
  parameters: BuffSkillParameters  // パラメータ設定
}

interface BuffSkillParameters {
  skillLevel?: number      // スキルレベル（1-10）
  stackCount?: number      // 重ねがけ数（トルネードランス等）
  playerCount?: number     // プレイヤー数（ナイトプレッジ等）
  refinement?: number      // 精錬値（ナイトプレッジ等）
  spUsed?: number         // 使用SP（エターナルナイトメア等）
  isCaster?: number       // 使用者フラグ（ブレイブ等）
}

type BuffSkillCategory = 
  | 'mastery' | 'blade' | 'shoot' | 'halberd' | 'mononofu'
  | 'dualSword' | 'sprite' | 'darkPower' | 'shield' | 'knight'
  | 'hunter' | 'assassin' | 'ninja' | 'support' | 'survival'
  | 'battle' | 'pet' | 'minstrel' | 'partisan'
```

### 11.2 武器種とマスタリスキルの連動

**データ保存方法**:
- 全てのマスタリスキルの状態は常に保存される
- 表示・非表示は武器種に応じてUI側で制御
- **武器種変更時はマスタリスキル設定がリセットされる**

**武器種マッピング**:
```typescript
const weaponTypeToMasterySkills: Record<WeaponType, string[]> = {
  '素手': ['shield_mastery'],
  '片手剣': ['blade_mastery', 'shield_mastery'],
  '双剣': ['blade_mastery', 'dual_mastery'],
  '両手剣': ['blade_mastery'],
  '手甲': ['martial_mastery', 'shield_mastery'],
  '旋風槍': ['halberd_mastery'],
  '抜刀剣': [], // 該当するマスタリスキルなし（マスタリ系統全体を非表示）
  '弓': ['shoot_mastery'],
  '自動弓': ['shoot_mastery', 'shield_mastery'],
  '杖': ['magic_mastery', 'shield_mastery'],
  '魔導具': ['magic_mastery'],
}
```

**武器種変更時の動作**:
- 武器種変更を検知した時点で全マスタリスキルをリセット
- リセット後のマスタリスキルは無効状態・デフォルトパラメータに設定
- 新しい武器種に対応するマスタリスキルのみが表示される
- 抜刀剣の場合はマスタリスキル系統全体が非表示

**保存データ最適化**:
- リセットされたマスタリスキルもパラメータ含めて完全保存
- セーブデータ切り替え時に全てのスキル状態を復元
- 武器種変更によるリセットはリアルタイムでLocalStorageに反映

### 11.3 デフォルトバフスキルデータ

```typescript
const getDefaultBuffSkills = (): BuffSkillFormData => ({
  skills: [
    // マスタリスキル
    { id: 'halberd_mastery', name: 'ハルバードマスタリ', category: 'mastery', isEnabled: false, parameters: { skillLevel: 1 } },
    { id: 'blade_mastery', name: 'ブレードマスタリ', category: 'mastery', isEnabled: false, parameters: { skillLevel: 1 } },
    { id: 'shoot_mastery', name: 'シュートマスタリ', category: 'mastery', isEnabled: false, parameters: { skillLevel: 1 } },
    { id: 'magic_mastery', name: 'マジックマスタリ', category: 'mastery', isEnabled: false, parameters: { skillLevel: 1 } },
    { id: 'martial_mastery', name: 'マーシャルマスタリ', category: 'mastery', isEnabled: false, parameters: { skillLevel: 1 } },
    { id: 'dual_mastery', name: 'デュアルマスタリ', category: 'mastery', isEnabled: false, parameters: { skillLevel: 1 } },
    { id: 'shield_mastery', name: 'シールドマスタリ', category: 'mastery', isEnabled: false, parameters: { skillLevel: 1 } },
    
    // その他58種類のバフスキル（詳細はbuff-skill.mdを参照）
    // 全てisEnabled: false, パラメータは最小値で初期化
  ]
})
```

### 11.3 バフスキルのデータ管理

**保存データ**:
- バフスキルの設定状態は各セーブデータに保存
- オン/オフ状態とパラメータ値を保持
- セーブデータ切り替え時に設定も切り替わる

**バリデーション**:
```typescript
export function validateBuffSkill(skill: BuffSkill): DataValidation
export function validateBuffSkillParameters(parameters: BuffSkillParameters, category: BuffSkillCategory): boolean
```

**データ変換**:
- Zustand ⟷ LocalStorage間のデータ変換
- 型安全性を保った状態でのシリアライゼーション
- バージョン互換性の確保

---

## 12. ユーザーカスタム敵情報データ構造

### 12.1 UserEnemyインターフェース

```typescript
interface UserEnemy {
  id: string                    // 一意識別子（ユーザー生成）
  name: string                  // 敵名（ユーザー入力）
  level: number                 // レベル (1-999)
  stats: EnemyStats            // 基本ステータス
  category: EnemyCategory      // 敵カテゴリ
  createdAt: string            // 作成日時 (ISO string)
  updatedAt: string            // 更新日時 (ISO string)
  isFavorite: boolean          // お気に入り設定
}

// EnemyStatsは技術仕様書と同一
interface EnemyStats {
  DEF: number                  // 物理防御力 (0-9999)
  MDEF: number                 // 魔法防御力 (0-9999)
  physicalResistance: number   // 物理耐性% (-100-100)
  magicalResistance: number    // 魔法耐性% (-100-100)
  resistCritical: number       // クリティカル耐性 (0-999) ※プリセット敵情報では0、ユーザーが調整可能
  requiredHIT: number          // 必要HIT (0-9999) ※プリセット敵情報では0、ユーザーが調整可能
}

type EnemyCategory = 'mob' | 'fieldBoss' | 'boss' | 'raidBoss'
```

### 11.2 カスタム敵情報の管理

**作成・編集機能**:
- 敵情報作成フォーム（プリセットからコピー or 新規作成）
- 全ステータスの手動入力・調整
- カテゴリ選択（モブ、フィールドボス、ボス、レイドボス）
- お気に入り設定（よく使用する敵情報の管理）

**データ操作**:
- 作成、編集、削除、複製
- 名前変更、カテゴリ変更
- お気に入り設定の切り替え
- 一括操作（複数選択での削除等）

**検索・フィルタリング**:
- 名前による検索
- カテゴリによるフィルタリング
- お気に入りによるフィルタリング
- レベル範囲での絞り込み
- 作成日・更新日での並び替え

### 11.3 参照・統合機能

**セーブデータとの連携**:
```typescript
// セーブデータの敵情報選択
interface EnemyFormData {
  selectedId: string | null      // プリセット敵情報ID or カスタム敵情報ID
  type: 'preset' | 'custom'      // データソースの識別
  // 手動入力値（プリセット・カスタム選択後のresistCriticalとrequiredHIT調整用）
  manualOverrides?: {
    resistCritical?: number      // プリセット値（0）からの調整値
    requiredHIT?: number         // プリセット値（0）からの調整値
  }
}
```

**削除時の影響確認**:
- カスタム敵情報を参照しているセーブデータの検索
- 削除確認ダイアログでの警告表示
- 影響を受けるセーブデータ一覧の表示

**データ整合性管理**:
- 削除されたカスタム敵情報への参照を自動修復
- セーブデータ読み込み時の参照先存在確認
- 破損した参照のエラーハンドリング

---

## 12. ユーザーカスタム装備データ構造

### 12.1 UserEquipmentインターフェース

```typescript
interface UserEquipment {
  id: string                      // 一意識別子（ユーザー生成）
  name: string                    // 装備名（ユーザー入力）
  category: EquipmentCategory     // 装備カテゴリ
  properties: Partial<EquipmentProperties> // 付与プロパティ
  weaponStats?: WeaponStats       // mainWeaponカテゴリ専用：武器基本ステータス（オプション）
  crystalSlots?: CrystalSlots     // mainWeapon, body, additional, special専用：クリスタル枠（オプション）
  createdAt: string               // 作成日時 (ISO string)
  updatedAt: string               // 更新日時 (ISO string)
  isFavorite: boolean             // お気に入り設定
}

// 技術仕様書と同一の型定義
interface WeaponStats {
  ATK?: number       // 武器ATK（省略時はWeaponFormの値を使用）
  stability?: number // 安定率（省略時はWeaponFormの値を使用）
  refinement?: number // 精錬値（省略時はWeaponFormの値を使用）
}

interface CrystalSlots {
  slot1?: string     // クリスタルID（省略時は未装着）
  slot2?: string     // クリスタルID（省略時は未装着）
}

type EquipmentCategory = 
  | 'mainWeapon'      // メイン装備
  | 'body'            // 体装備
  | 'additional'      // 追加装備
  | 'special'         // 特殊装備
  | 'subWeapon'       // サブ武器
  | 'fashion1'        // オシャレ装備1
  | 'fashion2'        // オシャレ装備2
  | 'fashion3'        // オシャレ装備3
  | 'freeInput1'      // 自由入力1
  | 'freeInput2'      // 自由入力2
  | 'freeInput3'      // 自由入力3
```

### 12.2 カスタム装備の管理

**作成・編集機能**:
- 装備作成フォーム（プリセットからコピー or 新規作成）
- 装備カテゴリ選択（11カテゴリから選択）
- 全プロパティの手動入力・調整（%系: -1000～1000、固定値: -99999～99999）
- mainWeaponの場合：武器基本ステータス設定（ATK、安定率、精錬値）
- mainWeapon/body/additional/specialの場合：クリスタルスロット設定
- お気に入り設定（よく使用する装備の管理）

**データ操作**:
- 作成、編集、削除、複製
- 名前変更、カテゴリ変更
- お気に入り設定の切り替え
- 一括操作（複数選択での削除等）
- プロパティの一括設定・クリア

**検索・フィルタリング**:
- 名前による検索
- カテゴリによるフィルタリング
- お気に入りによるフィルタリング
- プロパティ値による絞り込み（特定のプロパティを持つ装備）
- 作成日・更新日での並び替え

### 12.3 プロパティ管理

**プロパティ入力システム**:
- 70+種類の全プロパティに対応
- プロパティ種別の自動判定（%系 vs 固定値）
- 値範囲の自動バリデーション
- プロパティの有効/無効切り替え
- よく使用するプロパティの優先表示

**プロパティテンプレート機能**:
- 攻撃特化、防御特化、魔法特化等のテンプレート
- ユーザー独自テンプレートの保存・読み込み
- テンプレート適用後の個別調整

### 12.4 クリスタルスロット管理

**対象カテゴリ**:
- mainWeapon: weapon + normal クリスタル装着可能
- body: armor + normal クリスタル装着可能
- additional: additional + normal クリスタル装着可能
- special: special + normal クリスタル装着可能

**スロット機能**:
- 各カテゴリ2スロット装備
- クリスタル選択UI（カテゴリ対応フィルタリング）
- スロット間でのクリスタル交換
- 空スロット許可（未装着状態）

### 12.5 参照・統合機能

**セーブデータとの連携**:
```typescript
// セーブデータの装備選択
interface EquipmentFormData {
  mainWeapon: {
    selectedId: string | null    // プリセット装備ID or カスタム装備ID
    type: 'preset' | 'custom'    // データソースの識別
  }
  body: {
    selectedId: string | null
    type: 'preset' | 'custom'
  }
  // ... 他の装備スロット
}
```

**削除時の影響確認**:
- カスタム装備を参照しているセーブデータの検索
- 削除確認ダイアログでの警告表示
- 影響を受けるセーブデータ一覧の表示

**データ整合性管理**:
- 削除されたカスタム装備への参照を自動修復
- セーブデータ読み込み時の参照先存在確認
- クリスタルスロットの参照整合性チェック
- 破損した参照のエラーハンドリング

---

## 13. ユーザーカスタムクリスタルデータ構造

### 13.1 UserCrystalインターフェース

```typescript
interface UserCrystal {
  id: string                       // 一意識別子（ユーザー生成）
  name: string                     // クリスタル名（ユーザー入力）
  type: CrystalType               // クリスタルタイプ
  properties: Partial<EquipmentProperties> // 付与プロパティ
  description?: string             // 説明文（オプション）
  isCustom: true                  // カスタムクリスタル識別フラグ
  createdAt: string               // 作成日時 (ISO string)
  updatedAt: string               // 更新日時 (ISO string)
  isFavorite?: boolean            // お気に入り設定（オプション）
}

// クリスタルタイプ定義（技術仕様書と同一）
type CrystalType = 'weapon' | 'armor' | 'additional' | 'special' | 'normal'

// 既存のPresetCrystalとの統合型
type Crystal = PresetCrystal | UserCrystal
```

### 13.2 クリスタルタイプシステム

**タイプ別装着制限**（要件定義書・技術仕様書準拠）:
- **weapon**: weaponクリスタルスロット専用 + normalクリスタルは全スロット装着可能
- **armor**: armorクリスタルスロット専用 + normalクリスタルは全スロット装着可能  
- **additional**: additionalクリスタルスロット専用 + normalクリスタルは全スロット装着可能
- **special**: specialクリスタルスロット専用 + normalクリスタルは全スロット装着可能
- **normal**: 全クリスタルスロット（weapon/armor/additional/special）に装着可能

**クリスタルスロット構成**（技術仕様書準拠）:
```typescript
interface CrystalSlots {
  weapon1: string | null    // weaponタイプ or normalタイプのクリスタルID
  weapon2: string | null    // weaponタイプ or normalタイプのクリスタルID
  armor1: string | null     // armorタイプ or normalタイプのクリスタルID
  armor2: string | null     // armorタイプ or normalタイプのクリスタルID
  additional1: string | null // additionalタイプ or normalタイプのクリスタルID
  additional2: string | null // additionalタイプ or normalタイプのクリスタルID
  special1: string | null   // specialタイプ or normalタイプのクリスタルID
  special2: string | null   // specialタイプ or normalタイプのクリスタルID
}
```

### 13.3 カスタムクリスタルの管理

**作成・編集機能**:
- クリスタル作成フォーム（プリセットからコピー or 新規作成）
- クリスタルタイプ選択（5タイプから選択：weapon/armor/additional/special/normal）
- 全プロパティの手動入力・調整（技術仕様書の範囲準拠）:
  - %系プロパティ: -1000～1000
  - 固定値プロパティ: -99999～99999
- プロパティの有効/無効切り替え
- 説明文の追加（オプション）
- お気に入り設定（よく使用するクリスタルの管理）

**データ操作**:
- 作成、編集、削除、複製
- 名前変更、タイプ変更（装着制限を考慮したワーニング表示）
- お気に入り設定の切り替え
- 一括操作（複数選択での削除等）
- プロパティの一括設定・クリア

### 13.4 検索・フィルタリング機能

**基本検索**:
- 名前による検索（部分一致）
- クリスタルタイプによるフィルタリング
- お気に入りによるフィルタリング
- カスタム/プリセットの切り替え表示

**高度なフィルタリング**:
- プロパティ値による絞り込み（特定のプロパティを持つクリスタル）
- プロパティ値の範囲指定（ATK%が10以上のクリスタル等）
- 複数プロパティの組み合わせ検索
- 作成日・更新日での並び替え

### 13.5 参照・統合機能

**セーブデータとの連携**:
```typescript
// セーブデータのクリスタル選択
interface CrystalFormData {
  weapon1: {
    selectedId: string | null    // プリセット or カスタムクリスタルID
    type: 'preset' | 'custom'    // データソースの識別
  }
  weapon2: {
    selectedId: string | null
    type: 'preset' | 'custom'
  }
  // ... 他のクリスタルスロット（armor1-2, additional1-2, special1-2）
}
```

**装着制限チェック**:
```typescript
// クリスタル装着可能性の判定
function canEquipCrystal(crystalId: string, slotType: 'weapon' | 'armor' | 'additional' | 'special'): boolean {
  const crystal = getCrystalById(crystalId)
  if (!crystal) return false
  
  // normalタイプは全スロットに装着可能
  if (crystal.type === 'normal') return true
  
  // 他のタイプは対応するスロットのみ装着可能
  return crystal.type === slotType
}
```

**削除時の影響確認**:
- カスタムクリスタルを装着しているセーブデータの検索
- 削除確認ダイアログでの警告表示
- 影響を受けるセーブデータ一覧の表示（どのスロットに装着されているか詳細表示）

**データ整合性管理**:
- 削除されたカスタムクリスタルへの参照を自動修復（null に変更）
- セーブデータ読み込み時の参照先存在確認
- 装着制限違反の検出と自動修復
- 破損した参照のエラーハンドリング

### 13.6 プリセット・カスタム統合システム

**統合データアクセス**（既存のcrystalDatabase.tsパターン準拠）:
```typescript
// プリセット + カスタムの統合取得
export function getAllCrystals(): (PresetCrystal | UserCrystal)[]
export function getCrystalsByType(type: CrystalType): (PresetCrystal | UserCrystal)[]
export function getCrystalById(id: string): (PresetCrystal | UserCrystal) | undefined

// プリセットのみ取得
export function getPresetCrystals(): PresetCrystal[]

// カスタムのみ取得
export function getUserCrystals(): UserCrystal[]

// 存在確認
export function crystalExists(id: string): boolean
```

**データ識別**:
- プリセットクリスタル: `isCustom` プロパティなし
- カスタムクリスタル: `isCustom: true` プロパティ有り
- ID重複の防止（プリセットIDとの衝突回避）

### 13.7 ローカルストレージ管理

**ストレージキー**（既存のcrystalDatabase.ts準拠）:
```typescript
const USER_CRYSTALS_KEY = 'toram_user_crystals'

// ストレージキー統合（全体設計との整合性）
const STORAGE_KEYS = {
  CUSTOM_CRYSTALS: 'toram_user_crystals',  // UserCrystal[]
  // 他のカスタムデータキーとの統合
}
```

**データ永続化**:
- カスタムクリスタルはLocalStorageに保存
- プリセットクリスタルは静的JSONファイルから読み込み

**データサイズ見積もり**:
- カスタムクリスタル1個あたり約0.5-1KB
- 100個のカスタムクリスタルで約50-100KB
- LocalStorage容量の約1-2%程度

### 13.8 API設計

```typescript
// src/utils/crystalDatabase.ts の拡張

// カスタムクリスタル管理（既存の関数を拡張）
export function saveUserCrystal(crystal: Omit<UserCrystal, 'isCustom' | 'createdAt' | 'updatedAt'>): void
export function deleteUserCrystal(id: string): void

// 新規追加する関数
export function updateUserCrystal(id: string, updates: Partial<UserCrystal>): void
export function renameUserCrystal(id: string, newName: string): void
export function toggleCrystalFavorite(id: string): void
export function duplicateUserCrystal(id: string, newName?: string): string

// 検索・フィルタリング
export function searchCrystals(query: string, filters?: CrystalFilters): Crystal[]
export function getCrystalsByProperty(property: keyof EquipmentProperties, minValue?: number): Crystal[]

// 装着制限チェック
export function validateCrystalEquipment(crystalId: string, slotType: string): boolean
export function getEquippableCrystals(slotType: 'weapon' | 'armor' | 'additional' | 'special'): Crystal[]

// セーブデータ影響確認
export function findSaveDataUsingCustomCrystal(crystalId: string): SaveData[]
export function validateCrystalReferences(saveData: SaveData): { valid: boolean, errors: string[] }

```

### 13.9 UI/UX設計

**クリスタル管理画面**（要件定義書のUI要件準拠）:
```
┌─────────────────────────────────────────────────────┐
│ カスタムクリスタル管理                                 │
├─────────────────────────────────────────────────────┤
│ [新規作成]                                           │
│ 検索: [____________] [weapon▼] [お気に入りのみ☐]       │
├─────────────────────────────────────────────────────┤
│ ☆ カスタム火力クリスタル (weapon) [編集][複製][削除]   │
│   ATK%+15, クリティカルダメージ%+12, 物理貫通%+8       │
│ ○ 防御特化クリスタル (armor) [編集][複製][削除]        │
│   HP%+20, VIT%+10, 物理耐性%+5                       │
│ ...                                               │
└─────────────────────────────────────────────────────┘
```

**クリスタル選択UI**（要件定義書のモーダル方式準拠）:
- オーバーレイモーダル方式での選択画面
- グリッドレイアウトでのクリスタ一覧表示
- クリスタカード形式（名前、効果、説明表示）
- タイプ別フィルタリング（専用/ノーマル）
- 背景クリック・ESCキーでモーダル閉じる
- プリセット + カスタムの統合表示

**クリスタル編集フォーム**:
- タイプ選択ドロップダウン（変更時の装着制限ワーニング）
- プロパティ一覧（技術仕様書の全プロパティ対応）
- アクティブプロパティのみ表示切り替え
- プロパティテンプレート機能（よく使用する組み合わせの保存）
- リアルタイムプレビュー（効果値の表示）

### 13.10 プロパティ管理システム

**プロパティ入力システム**（技術仕様書のEquipmentPropertiesに完全対応）:
- 240+種類の全プロパティに対応（技術仕様書準拠）
- プロパティカテゴリ別表示:
  - 基本攻撃力系（ATK%、ATK、MATK%、MATK等）
  - ステータス系（STR%、STR、INT%、INT等）
  - 戦闘系（クリティカル、貫通、威力等）
  - 防御・耐性系（物理耐性、魔法耐性、属性耐性等）
  - 特殊系（バリア、追撃、軽減等）
- プロパティ種別の自動判定（%系 vs 固定値）
- 値範囲の自動バリデーション（技術仕様書準拠）
- よく使用するプロパティの優先表示

**プロパティテンプレート機能**:
- 攻撃特化、防御特化、魔法特化等のテンプレート
- ユーザー独自テンプレートの保存・読み込み
- テンプレート適用後の個別調整

### 13.11 データ移行・バージョン管理

**データ構造の拡張性**:
- 新プロパティ追加時の後方互換性
- バージョン情報の付与
- マイグレーション処理の実装

**エラーハンドリング**:
- LocalStorageアクセスエラー対応
- データ破損時の復旧機能
- 参照整合性エラーの自動修復

---

## 14. 料理フォームデータ構造 (FoodFormData)

### 14.1 FoodFormDataインターフェース

```typescript
interface FoodFormData {
  slot1: FoodSlotData
  slot2: FoodSlotData
  slot3: FoodSlotData
  slot4: FoodSlotData
  slot5: FoodSlotData
}

interface FoodSlotData {
  selectedFood: FoodType    // 選択された料理タイプ
  level: number            // 料理レベル (1-10、「なし」の場合は0)
}

type FoodType = 
  | 'none'                    // なし
  | 'okaka_onigiri'          // おかかおにぎり(STR)
  | 'sake_onigiri'           // 鮭おにぎり(DEX)
  | 'umeboshi_onigiri'       // 梅干しおにぎり(INT)
  | 'mentaiko_onigiri'       // 明太子おにぎり(AGI)
  | 'tuna_mayo_onigiri'      // ツナマヨおにぎり(VIT)
  | 'shoyu_ramen'            // しょうゆラーメン(命中)
  | 'zokusei_pasta'          // 属性パスタ(属性有利共通)
  | 'takoyaki'               // たこ焼き(クリ率)
  | 'yakisoba'               // 焼きそば(攻撃MP回復)
  | 'golden_fried_rice'      // 黄金チャーハン(HP)
  | 'ankake_fried_rice'      // あんかけチャーハン(MP)
  | 'margherita_pizza'       // マルゲリータピザ(武器ATK+)
  | 'diabola_pizza'          // ディアボラピザ(ATK+)
  | 'seafood_pizza'          // シーフードピザ(MATK+)
  | 'beef_stew'              // ビーフシチュー(ヘイト+)
  | 'white_stew'             // ホワイトシチュー(ヘイト-)
  | 'beef_burger'            // ビーフバーガー(物理耐性)
  | 'fish_burger'            // フィッシュバーガー(魔法耐性)
```

### 14.2 料理データの管理方針

**シンプルな値保存方式**（技術仕様書の4.4節準拠）:
- 料理データは5スロットの直接的な値保存
- 装備のような「プリセット選択 + カスタム管理」は行わない
- ユーザーが選択した料理タイプとレベルをそのままセーブデータに保存

**理由**:
- 料理は選択式のシンプルなバフシステム
- 装備のような複雑なプロパティシステムは不要
- レベル設定によるリニアな効果計算
- ユーザーの直接選択による簡潔性を重視

### 14.3 セーブデータとの連携

**セーブデータ構造への統合**:
```typescript
interface SaveData {
  id: string
  name: string
  isDefault: boolean
  createdAt: string
  updatedAt: string
  order: number
  data: {
    baseStats: BaseStatsFormData
    weapons: WeaponFormData
    crystals: CrystalFormData
    equipments: EquipmentFormData
    food: FoodFormData              // 料理情報
    enemy: EnemyFormData
  }
}
```

**デフォルト値**:
```typescript
const getDefaultFood = (): FoodFormData => ({
  slot1: { selectedFood: 'none', level: 0 },
  slot2: { selectedFood: 'none', level: 0 },
  slot3: { selectedFood: 'none', level: 0 },
  slot4: { selectedFood: 'none', level: 0 },
  slot5: { selectedFood: 'none', level: 0 }
})
```

### 14.4 ローカルストレージ管理

**保存データ構造**:
```typescript
// セーブデータに直接組み込まれる形式
interface SaveData {
  // ... 他のフィールド
  data: {
    // ... 他のフォームデータ
    food: FoodFormData           // 料理設定
  }
}
```

**データサイズ見積もり**:
- 料理データ1セット（5スロット）あたり約0.1-0.2KB
- 軽量なデータ構造でストレージ容量への影響は最小限

### 14.5 バリデーション仕様

**Zodスキーマ定義**（技術仕様書準拠）:
```typescript
export const foodSlotSchema = z.object({
  selectedFood: z.string(),
  level: z.number()
    .min(0, 'レベルは0以上である必要があります')
    .max(10, 'レベルは10以下である必要があります')
    .refine((value, ctx) => {
      // 「なし」が選択されている場合はレベルは0でなければならない
      const selectedFood = ctx.parent?.selectedFood
      if (selectedFood === 'none' && value !== 0) {
        return false
      }
      // 「なし」以外が選択されている場合はレベルは1-10でなければならない
      if (selectedFood !== 'none' && (value < 1 || value > 10)) {
        return false
      }
      return true
    }, 'レベルが料理選択と矛盾しています')
})

export const foodFormSchema = z.object({
  slot1: foodSlotSchema,
  slot2: foodSlotSchema,
  slot3: foodSlotSchema,
  slot4: foodSlotSchema,
  slot5: foodSlotSchema
})

export type FoodFormData = z.infer<typeof foodFormSchema>
```

**値の制限**:
- **料理レベル**: 0-10（「なし」の場合は0、それ以外は1-10）
- **料理タイプ**: 19種類の定義済み料理から選択

### 14.6 データ整合性・エラーハンドリング

**データ検証**:
```typescript
function validateFoodFormData(data: FoodFormData): DataValidation {
  const errors: string[] = []
  const warnings: string[] = []
  
  // 各スロットの検証
  Object.entries(data).forEach(([slotName, slotData]) => {
    if (slotData.selectedFood === 'none' && slotData.level !== 0) {
      errors.push(`${slotName}: 「なし」選択時はレベルは0である必要があります`)
    }
    
    if (slotData.selectedFood !== 'none' && (slotData.level < 1 || slotData.level > 10)) {
      errors.push(`${slotName}: 料理選択時はレベルは1-10である必要があります`)
    }
  })
  
  return {
    isValid: errors.length === 0,
    errors,
    warnings,
    brokenReferences: [] // 料理データは参照なしのため空配列
  }
}
```

**エラー復旧**:
- 範囲外レベル値の自動修正
- 無効な料理タイプの自動「なし」設定
- データ破損時のデフォルト値復元

### 14.7 効果計算システム（将来実装予定）

**料理効果の概念**:
- 各料理タイプとレベルに応じた効果値の計算機能
- 現在のフェーズでは入力・保存機能に集中
- 効果計算ロジックは後のフェーズで実装予定

### 14.8 フォーム管理システム

**React Hook Form統合**:
```typescript
interface FoodFormProps {
  food: FoodFormData
  onFoodChange: (food: FoodFormData) => void
}

// フォーム実装パターン
const {
  register,
  watch,
  formState: { errors },
  setValue,
  getValues,
} = useForm<FoodFormData>({
  resolver: zodResolver(foodFormSchema),
  defaultValues: food,
  mode: 'onChange',
})

// リアルタイムバリデーション
const currentFoodData = watch()
// 効果計算は将来実装予定
```

## 15. 武器フォームデータ構造 (WeaponFormData)

### 14.1 WeaponFormDataインターフェース

```typescript
interface WeaponFormData {
  mainWeapon: MainWeaponFormData      // メイン武器情報
  subWeapon: SubWeaponFormData        // サブ武器情報
}

// メイン武器フォームデータ（既存のMainWeaponと同一構造）
interface MainWeaponFormData {
  weaponType: WeaponType              // 武器種
  ATK: number                         // 武器ATK (0-1500)
  stability: number                   // 安定率 (0-100)
  refinement: number                  // 精錬値 (0-15)
}

// サブ武器フォームデータ（既存のSubWeaponと同一構造）
interface SubWeaponFormData {
  weaponType: SubWeaponType           // サブ武器種
  ATK: number                         // 武器ATK (0-1500)
  stability: number                   // 安定率 (0-100)
  refinement: number                  // 精錬値 (0-15)
}

// 武器種定義（要件定義書・技術仕様書準拠）
type WeaponType = 
  | '片手剣'    // 片手剣
  | '双剣'      // 双剣
  | '両手剣'    // 両手剣
  | '手甲'      // 手甲
  | '旋風槍'    // 旋風槍（HB）
  | '抜刀剣'    // 抜刀剣
  | '弓'        // 弓
  | '自動弓'    // 自動弓
  | '杖'        // 杖
  | '魔導具'    // 魔導具
  | '素手'      // 素手

// サブ武器種定義（要件定義書・技術仕様書準拠）
type SubWeaponType = 'ナイフ' | '矢' | 'なし'
```

### 14.2 武器データの管理方針

**シンプルな値保存方式**:
- 武器データは装備選択システムとは独立した直接的な値保存
- 装備のような「プリセット選択 + カスタム管理」は行わない
- ユーザーが直接入力した値をそのままセーブデータに保存

**理由**:
- 武器は基本的なパラメータのみ（種類、ATK、安定率、精錬値）
- 装備のような複雑なプロパティシステムは不要
- ユーザーの直接入力による簡潔性を重視

### 14.3 セーブデータとの連携

**セーブデータ構造への統合**:
```typescript
interface SaveData {
  id: string
  name: string
  isDefault: boolean
  createdAt: string
  updatedAt: string
  order: number
  data: {
    baseStats: BaseStatsFormData
    weapons: WeaponFormData           // 武器情報
    crystals: CrystalFormData
    equipments: EquipmentFormData
    enemy: EnemyFormData
  }
}
```

**デフォルト値**:
```typescript
const getDefaultWeapons = (): WeaponFormData => ({
  mainWeapon: {
    weaponType: '片手剣',             // デフォルト武器種
    ATK: 0,                          // 最小値
    stability: 0,                    // 最小値
    refinement: 0                    // 最小値
  },
  subWeapon: {
    weaponType: 'なし',              // デフォルト：サブ武器なし
    ATK: 0,                          // 最小値
    stability: 0,                    // 最小値
    refinement: 0                    // 最小値
  }
})
```

### 14.4 バリデーション仕様

**Zodスキーマ定義**（既存の実装準拠）:
```typescript
// メイン武器バリデーション
export const mainWeaponSchema = z.object({
  weaponType: z.string(),
  ATK: z.number()
    .min(0, 'ATKは0以上である必要があります')
    .max(1500, 'ATKは1500以下である必要があります'),
  stability: z.number()
    .min(0, '安定率は0以上である必要があります')
    .max(100, '安定率は100以下である必要があります'),
  refinement: z.number()
    .min(0, '精錬値は0以上である必要があります')
    .max(15, '精錬値は15以下である必要があります')
})

// サブ武器バリデーション
export const subWeaponSchema = z.object({
  weaponType: z.string(),
  ATK: z.number()
    .min(0, 'ATKは0以上である必要があります')
    .max(1500, 'ATKは1500以下である必要があります'),
  stability: z.number()
    .min(0, '安定率は0以上である必要があります')
    .max(100, '安定率は100以下である必要があります'),
  refinement: z.number()
    .min(0, '精錬値は0以上である必要があります')
    .max(15, '精錬値は15以下である必要があります')
})

// 統合バリデーションスキーマ
export const weaponFormSchema = z.object({
  mainWeapon: mainWeaponSchema,
  subWeapon: subWeaponSchema
})

export type WeaponFormData = z.infer<typeof weaponFormSchema>
```

**値の範囲制限**（技術仕様書準拠）:
- **武器ATK**: 0-1500
- **安定率**: 0-100%
- **精錬値**: 0-15

### 14.5 フォーム管理システム

**React Hook Form統合**（既存実装パターン準拠）:
```typescript
interface WeaponFormProps {
  mainWeapon: MainWeapon
  subWeapon: SubWeapon
  onMainWeaponChange: (weapon: MainWeapon) => void
  onSubWeaponChange: (weapon: SubWeapon) => void
}

// フォーム実装パターン
const {
  register: registerMain,
  watch: watchMain,
  formState: { errors: errorsMain },
  setValue: setValueMain,
  getValues: getValuesMain,
} = useForm<MainWeaponFormData>({
  resolver: zodResolver(mainWeaponSchema),
  defaultValues: mainWeapon,
  mode: 'onChange',
})
```

**値制限ハンドリング**:
- onBlur時の自動値制限
- 範囲外値の自動修正
- リアルタイムバリデーション

### 14.7 セーブデータ管理

**セーブデータ操作**:
```typescript
// セーブデータ作成時
const newSaveData: SaveData = {
  // ... 他のフィールド
  data: {
    // ... 他のフォームデータ
    weapons: getCurrentWeaponFormData(), // 現在の武器フォーム状態
  }
}

// セーブデータ読み込み時
function loadWeaponData(saveData: SaveData) {
  const weaponData = saveData.data.weapons
  setMainWeapon(weaponData.mainWeapon)
  setSubWeapon(weaponData.subWeapon)
}
```

### 14.8 データ整合性・エラーハンドリング

**データ検証**:
```typescript
function validateWeaponFormData(data: WeaponFormData): DataValidation {
  const errors: string[] = []
  const warnings: string[] = []
  
  // 範囲チェック
  if (data.mainWeapon.ATK < 0 || data.mainWeapon.ATK > 1500) {
    errors.push('メイン武器ATKが範囲外です')
  }
  
  if (data.mainWeapon.stability < 0 || data.mainWeapon.stability > 100) {
    errors.push('メイン武器安定率が範囲外です')
  }
  
  if (data.mainWeapon.refinement < 0 || data.mainWeapon.refinement > 15) {
    errors.push('メイン武器精錬値が範囲外です')
  }
  
  // サブ武器の同様チェック
  // ...
  
  return {
    isValid: errors.length === 0,
    errors,
    warnings,
    brokenReferences: [] // 武器データは参照なしのため空配列
  }
}
```

**エラー復旧**:
- 範囲外値の自動修正
- 無効な武器種の自動デフォルト設定
- データ破損時のデフォルト値復元

### 14.9 既存システムとの統合

**装備システムとの関係**:
- 装備の「mainWeapon」カテゴリはWeaponFormと連携
- 装備選択時にWeaponFormの値を上書き可能
- WeaponForm優先

**クリスタルシステムとの関係**:
- クリスタはWeaponFormとは独立管理
- CrystalFormDataで装着クリスタを管理
- 武器種による装着制限は適用

**計算システムとの関係**:
- WeaponFormDataは計算エンジンの入力パラメータ
- 武器種別の計算式適用
- ATK、安定率、精錬値の計算への反映

---

**作成日**: 2025-01-16
**更新日**: 2025-01-17
**対象システム**: トーラムオンライン ダメージ計算ツール
**設計対象**: ローカルストレージ・セーブデータ管理システム