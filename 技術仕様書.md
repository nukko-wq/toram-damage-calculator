# トーラムオンライン ダメージ計算ツール 技術仕様書

## 1. 概要
本仕様書は、トーラムオンライン ダメージ計算ツールの技術的な実装詳細とデータベース構造を定義します。

## 2. 技術スタック
- **フロントエンド**: Next.js 15 + React 19
- **言語**: TypeScript (strict mode)
- **スタイリング**: Tailwind CSS v4
- **状態管理**: Zustand (軽量で型安全)
- **フォームバリデーション**: Zod + React Hook Form
- **データ管理**: JSON + LocalStorage
- **コードフォーマット**: Biome

## 3. プロジェクト構造

```
src/
├── app/                    # Next.js App Router
├── components/             # Reactコンポーネント（機能別ディレクトリ構造）
│   ├── base-stats/         # 基本ステータスフォーム
│   ├── weapon/             # 武器フォーム
│   ├── crystal/            # クリスタル関連（フォーム、カード、モーダル）
│   ├── equipment/          # 装備関連（フォーム、カード、モーダル、エディター）
│   ├── enemy/              # 敵関連（フォーム、カード、モーダル）
│   ├── food/               # 料理フォーム
│   ├── buff-skill/         # バフスキル関連（フォーム、カード、パラメータ）
│   ├── buff-item/          # バフアイテム関連（フォーム、カード、モーダル）
│   ├── save-data/          # セーブデータ管理関連
│   ├── ui/                 # 汎用UIコンポーネント
│   ├── summary/            # 結果表示・サマリー
│   └── __tests__/          # テスト用コンポーネント
├── stores/                 # Zustand状態管理ストア
├── types/                  # TypeScript型定義
├── schemas/                # Zodバリデーションスキーマ
├── data/                   # 静的データ（JSON）
├── utils/                  # ユーティリティ関数
└── hooks/                  # カスタムフック（今後必要に応じて）
```

## 4. 状態管理アーキテクチャ

### 4.1 Zustand ストア構成

#### 4.1.1 ストア分割戦略
```
src/stores/
├── index.ts                # 全ストアのエクスポート
├── calculatorStore.ts      # 計算機データ管理
├── saveDataStore.ts        # セーブデータ管理  
└── uiStore.ts             # UI状態管理
```

#### 4.1.2 CalculatorStore
**責任**: 計算機の全データを一元管理
```typescript
interface CalculatorStore {
  data: CalculatorData
  hasUnsavedChanges: boolean
  isInitialized: boolean
  isLoading: boolean
  
  // 基本操作
  initialize: () => Promise<void>
  updateData: (data: CalculatorData) => void
  
  // 個別フォーム更新
  updateBaseStats: (stats: BaseStats) => void
  updateMainWeapon: (weapon: MainWeapon) => void
  updateSubWeapon: (weapon: SubWeapon) => void
  updateCrystals: (crystals: CrystalSlots) => void
  updateEquipment: (equipment: EquipmentSlots) => void
  updateFood: (food: FoodFormData) => void
  updateEnemy: (enemy: EnemyFormData) => void
  updateBuffSkills: (buffSkills: BuffSkillFormData) => void
  updateBuffItems: (buffItems: BuffItemFormData) => void
  
  // セーブデータ連携
  loadSaveData: (data: CalculatorData) => Promise<void>
  saveCurrentData: () => Promise<void>
}
```

#### 4.1.3 SaveDataStore
**責任**: セーブデータの管理とLocalStorage操作
```typescript
interface SaveDataStore {
  saveDataList: SaveDataItem[]        // ユーザー作成データのみ
  currentSaveId: string | null
  
  loadSaveDataList: () => Promise<void>                    // ユーザーデータのみロード
  switchSaveData: (saveId: string) => Promise<void>
  createSaveData: (name: string) => Promise<void>          // 作成後自動切り替え
  deleteSaveData: (saveId: string) => Promise<void>        // 全削除時メインデータ切り替え
  switchToMainData: () => Promise<void>                    // メインデータ切り替え専用
}
```

**新しい動作仕様**:
- `saveDataList`: デフォルトデータ（メインデータ）は含まない
- `createSaveData`: 作成後に自動的に作成したデータに切り替え
- `deleteSaveData`: 全ユーザーデータ削除時は自動的にメインデータに切り替え
- `switchToMainData`: 明示的なメインデータ切り替え機能

#### 4.1.4 UIStore
**責任**: UI状態の管理
```typescript
interface UIStore {
  showSaveManager: boolean
  setShowSaveManager: (value: boolean) => void
}
```

### 4.2 React Hook Form統合

#### 4.2.1 統合パターン
```typescript
// Zustandデータとの双方向バインディング
const storeData = useCalculatorStore(state => state.data.baseStats)
const updateStore = useCalculatorStore(state => state.updateBaseStats)

const form = useForm<FormData>({
  values: storeData, // Zustandからの自動同期
  mode: 'onChange',
})

// 変更をZustandに反映
useEffect(() => {
  const subscription = form.watch((value, { name, type }) => {
    if (isInitialized && name && value && type === 'change') {
      updateStore(value as FormData)
    }
  })
  return () => subscription.unsubscribe()
}, [form.watch, isInitialized, updateStore])
```

#### 4.2.2 初期化管理
セーブデータ切り替え時のちらつき防止:
```typescript
const [isInitialized, setIsInitialized] = useState(false)

useEffect(() => {
  setIsInitialized(false)
  const timer = setTimeout(() => setIsInitialized(true), 30)
  return () => clearTimeout(timer)
}, [storeData])
```

### 4.3 パフォーマンス最適化

- **セレクター活用**: 必要なデータのみ取得
- **細かい粒度**: 個別フィールドレベルでの更新
- **軽量初期化**: `values`プロパティによる自動同期
- **DevTools統合**: デバッグとモニタリング

## 5. データベース設計

### 5.1 装備データベース構造

#### 5.1.1 ファイル構成・データフロー
**初期データ配置**:
- **プリセットデータ**: `src/data/equipments.json`（静的ファイル）

**アプリ起動時の処理**:
```
アプリ起動 → プリセットJSONを読み込み → LocalStorageにコピー → 以降はLocalStorageから参照
```

**ローカルストレージキー**:
- **プリセット装備（コピー済み）**: LocalStorage (`preset_equipments`)
- **ユーザーカスタムデータ**: LocalStorage (`custom_equipments`)
- **統合アクセス**: 両方のデータを統一的に管理

#### 5.1.2 JSON構造

**プリセット装備データ構造**（初期配置用）:
```json
{
  "equipments": {
    "mainWeapon": [装備アイテム配列],
    "body": [装備アイテム配列],
    "additional": [装備アイテム配列],
    "special": [装備アイテム配列],
    "subWeapon": [装備アイテム配列],
    "fashion1": [装備アイテム配列],
    "fashion2": [装備アイテム配列],
    "fashion3": [装備アイテム配列],
    "freeInput1": [装備アイテム配列],
    "freeInput2": [装備アイテム配列],
    "freeInput3": [装備アイテム配列]
  }
}
```

**LocalStorage保存時の装備データ構造**（拡張版）:
```json
{
  "id": "equipment_id",
  "name": "装備名",
  "properties": { /* プロパティ */ },
  "source": "入手方法",
  "weaponStats": { /* mainWeapon専用 */ },
  "crystalSlots": { /* クリスタルスロット */ },
  "isPreset": true,           // プリセット由来フラグ
  "isFavorite": false,        // お気に入り設定
  "createdAt": "ISO string",  // 作成日時
  "updatedAt": "ISO string"   // 更新日時
}
```

#### 5.1.3 装備アイテム構造

**プリセット装備インターフェース**（初期配置用）:
```typescript
interface PresetEquipment {
  id: string                    // 一意識別子
  name: string                  // 装備名
  properties: Partial<EquipmentProperties> // 付与プロパティ
  source?: string              // 入手方法
  weaponStats?: WeaponStats    // mainWeaponカテゴリ専用：武器基本ステータス（オプション）
  crystalSlots?: CrystalSlots  // mainWeapon, body, additional, special専用：クリスタル枠（オプション）
}
```

**ローカルストレージ装備インターフェース**（拡張版）:
```typescript
interface LocalStorageEquipment extends PresetEquipment {
  isPreset: boolean            // プリセット由来かどうか
  isFavorite: boolean          // お気に入り設定
  createdAt: string           // 作成日時 (ISO string)
  updatedAt: string           // 更新日時 (ISO string)
}

// 統合型（アプリ内で使用する装備データ型）
type Equipment = LocalStorageEquipment

// mainWeaponカテゴリ専用の武器基本ステータス
interface WeaponStats {
  ATK?: number       // 武器ATK（省略時はWeaponFormの値を使用）
  stability?: number // 安定率（省略時はWeaponFormの値を使用）
  refinement?: number // 精錬値（省略時はWeaponFormの値を使用）
}

// mainWeapon, body, additional, special専用のクリスタル枠
interface CrystalSlots {
  slot1?: string     // クリスタルID（省略時は未装着）
  slot2?: string     // クリスタルID（省略時は未装着）
}

// 各装備カテゴリで利用可能なクリスタルタイプ
// mainWeapon: weapon, normal
// body: armor, normal  
// additional: additional, normal
// special: special, normal
```

#### 5.1.4 装備プロパティ設定値範囲

**プロパティ値設定範囲**
- %系プロパティ: -1000 ～ 1000
- 固定値プロパティ: -99999 ～ 99999

#### 5.1.5 装備プロパティ完全定義

```typescript
interface EquipmentProperties {
  // 基本攻撃力系
  ATK_Rate: number                     // ATK%
  ATK: number                          // ATK
  MATK_Rate: number                    // MATK%
  MATK: number                         // MATK
  WeaponATK_Rate: number               // 武器ATK%
  WeaponATK: number                    // 武器ATK
  
  // 防御力系
  DEF_Rate: number                     // DEF%
  DEF: number                          // DEF
  MDEF_Rate: number                    // MDEF%
  MDEF: number                         // MDEF
  
  // 貫通系
  PhysicalPenetration_Rate: number     // 物理貫通%
  MagicalPenetration_Rate: number      // 魔法貫通%
  ElementAdvantage_Rate: number        // 属性有利%
  
  // 威力系
  UnsheatheAttack_Rate: number         // 抜刀威力%
  UnsheatheAttack: number              // 抜刀威力
  ShortRangeDamage_Rate: number        // 近距離威力%
  LongRangeDamage_Rate: number         // 遠距離威力%
  
  // クリティカル系
  CriticalDamage_Rate: number          // クリティカルダメージ%
  CriticalDamage: number               // クリティカルダメージ
  Critical_Rate: number            // クリティカル率%
  Critical: number                 // クリティカル率
  
  // 安定率
  Stability_Rate: number               // 安定率%
  
  // HP/MP系
  HP_Rate: number                      // HP%
  HP: number                           // HP
  MP_Rate: number                      // MP%
  MP: number                           // MP
  
  // ステータス系
  STR_Rate: number                     // STR%
  STR: number                          // STR
  INT_Rate: number                     // INT%
  INT: number                          // INT
  VIT_Rate: number                     // VIT%
  VIT: number                          // VIT
  AGI_Rate: number                     // AGI%
  AGI: number                          // AGI
  DEX_Rate: number                     // DEX%
  DEX: number                          // DEX
  CRT_Rate: number                     // CRT%
  CRT: number                          // CRT
  MEN_Rate: number                     // MEN%
  MEN: number                          // MEN
  TEC_Rate: number                     // TEC%
  TEC: number                          // TEC
  
  // 命中・回避系
  Accuracy_Rate: number                // 命中%
  Accuracy: number                     // 命中
  Dodge_Rate: number                   // 回避%
  Dodge: number                        // 回避
  
  // 速度系
  AttackSpeed_Rate: number             // 攻撃速度%
  AttackSpeed: number                  // 攻撃速度
  CastingSpeed_Rate: number            // 詠唱速度%
  CastingSpeed: number                 // 詠唱速度
  MotionSpeed_Rate: number             // 行動速度%
  
  // MP回復系
  AttackMPRecovery_Rate: number        // 攻撃MP回復%
  AttackMPRecovery: number             // 攻撃MP回復
  
  // 耐性系
  PhysicalResistance_Rate: number      // 物理耐性%
  MagicalResistance_Rate: number       // 魔法耐性%
  AilmentResistance_Rate: number       // 異常耐性%
  
  // その他戦闘系
  Aggro_Rate: number                   // ヘイト%
  RevivalTime_Rate: number             // 復帰短縮%
  
  // 自然回復系
  NaturalHPRecovery_Rate: number       // HP自然回復%
  NaturalHPRecovery: number            // HP自然回復
  NaturalMPRecovery_Rate: number       // MP自然回復%
  NaturalMPRecovery: number            // MP自然回復
  
  // 特殊系
  ArmorBreak_Rate: number              // 防御崩し%
  Anticipate_Rate: number              // 先読み%
  GuardPower_Rate: number              // Guard力%
  GuardRecharge_Rate: number           // Guard回復%
  AvoidRecharge_Rate: number           // Avoid回復%
  ItemCooldown: number                 // 道具速度
  AbsoluteAccuracy_Rate: number        // 絶対命中%
  AbsoluteDodge_Rate: number           // 絶対回避%
  
  // ステータス連動攻撃力
  ATK_STR_Rate: number                 // ATK+(STR)%
  ATK_INT_Rate: number                 // ATK+(INT)%
  ATK_VIT_Rate: number                 // ATK+(VIT)%
  ATK_AGI_Rate: number                 // ATK+(AGI)%
  ATK_DEX_Rate: number                 // ATK+(DEX)%
  MATK_STR_Rate: number                // MATK+(STR)%
  MATK_INT_Rate: number                // MATK+(INT)%
  MATK_VIT_Rate: number                // MATK+(VIT)%
  MATK_AGI_Rate: number                // MATK+(AGI)%
  MATK_DEX_Rate: number                // MATK+(DEX)%
  
  // 属性耐性
  FireResistance_Rate: number          // 火耐性%
  WaterResistance_Rate: number         // 水耐性%
  WindResistance_Rate: number          // 風耐性%
  EarthResistance_Rate: number         // 地耐性%
  LightResistance_Rate: number         // 光耐性%
  DarkResistance_Rate: number          // 闇耐性%
  NeutralResistance_Rate: number       // 無耐性%
  
  // ダメージ軽減系
  LinearReduction_Rate: number         // 直線軽減%
  RushReduction_Rate: number           // 突進軽減%
  BulletReduction_Rate: number         // 弾丸軽減%
  ProximityReduction_Rate: number      // 周囲軽減%
  AreaReduction_Rate: number           // 範囲軽減%
  FloorTrapReduction_Rate: number      // 痛床軽減%
  MeteorReduction_Rate: number         // 隕石軽減%
  BladeReduction_Rate: number          // 射刃軽減%
  SuctionReduction_Rate: number        // 吸引軽減%
  ExplosionReduction_Rate: number      // 爆発軽減%
  
  // バリア系
  PhysicalBarrier: number              // 物理バリア
  MagicalBarrier: number               // 魔法バリア
  FractionalBarrier: number            // 割合バリア
  BarrierCooldown_Rate: number         // バリア速度%
  
  // 追撃系
  PhysicalFollowup_Rate: number        // 物理追撃%
  MagicalFollowup_Rate: number         // 魔法追撃%
}
```

#### 5.1.5 装備カテゴリ定義

```typescript
type EquipmentCategory = 
  | 'mainWeapon'      // メイン装備
  | 'body'      // 体装備
  | 'additional' // 追加装備
  | 'special'   // 特殊装備
  | 'subWeapon' // サブ武器
  | 'fashion1'  // オシャレ装備1
  | 'fashion2'  // オシャレ装備2
  | 'fashion3'  // オシャレ装備3
  | 'freeInput1' // 自由入力1
  | 'freeInput2' // 自由入力2
  | 'freeInput3' // 自由入力3
```

### 5.2 クリスタルデータベース構造

#### 5.2.1 ファイル構成・データフロー
**初期データ配置**:
- **プリセットデータ**: `src/data/crystals.json`（静的ファイル）

**アプリ起動時の処理**:
```
アプリ起動 → プリセットJSONを読み込み → LocalStorageにコピー → 以降はLocalStorageから参照
```

**ローカルストレージキー**:
- **プリセットクリスタル（コピー済み）**: LocalStorage (`preset_crystals`)
- **ユーザーカスタムデータ**: LocalStorage (`custom_crystals`)
- **統合アクセス**: 両方のデータを統一的に管理

#### 5.2.2 クリスタル構造

**プリセットクリスタルインターフェース**（初期配置用）:
```typescript
interface PresetCrystal {
  id: string
  name: string
  type: CrystalType
  properties: Partial<EquipmentProperties>
}
```

**ローカルストレージクリスタルインターフェース**（拡張版）:
```typescript
interface LocalStorageCrystal extends PresetCrystal {
  isPreset: boolean            // プリセット由来かどうか
  isFavorite: boolean          // お気に入り設定
  description?: string         // 説明文（オプション）
  createdAt: string           // 作成日時 (ISO string)
  updatedAt: string           // 更新日時 (ISO string)
}

// 統合型（アプリ内で使用するクリスタルデータ型）
type Crystal = LocalStorageCrystal

type CrystalType = 'weapon' | 'armor' | 'additional' | 'special' | 'normal'
```

### 5.3 敵情報データベース構造

#### 5.3.1 ファイル構成・データフロー
**初期データ配置**:
- **プリセットデータ**: `src/data/enemies.json`（静的ファイル）

**アプリ起動時の処理**:
```
アプリ起動 → プリセットJSONを読み込み → LocalStorageにコピー → 以降はLocalStorageから参照
```

**ローカルストレージキー**:
- **プリセット敵情報（コピー済み）**: LocalStorage (`preset_enemies`)
- **ユーザーカスタムデータ**: LocalStorage (`custom_enemies`)
- **統合アクセス**: 両方のデータを統一的に管理

#### 5.3.2 JSON構造

```json
{
  "enemies": {
    "mob": [敵情報配列],
    "fieldBoss": [敵情報配列],
    "boss": [敵情報配列],
    "raidBoss": [敵情報配列]
  }
}
```

#### 5.3.3 敵情報構造

**プリセット敵情報インターフェース**（初期配置用）:
```typescript
interface PresetEnemy {
  id: string                    // 一意識別子
  name: string                  // 敵名
  level: number                 // レベル (1-999)
  stats: EnemyStats            // 基本ステータス
  category: EnemyCategory      // 敵カテゴリ
}
```

**ローカルストレージ敵情報インターフェース**（拡張版）:
```typescript
interface LocalStorageEnemy extends PresetEnemy {
  isPreset: boolean            // プリセット由来かどうか
  isFavorite: boolean          // お気に入り設定
  createdAt: string           // 作成日時 (ISO string)
  updatedAt: string           // 更新日時 (ISO string)
}

// 統合型（アプリ内で使用する敵情報データ型）
type Enemy = LocalStorageEnemy

interface EnemyStats {
  DEF: number                  // 物理防御力 (0-9999)
  MDEF: number                 // 魔法防御力 (0-9999)
  physicalResistance: number   // 物理耐性% (-100-100)
  magicalResistance: number    // 魔法耐性% (-100-100)
  resistCritical: number       // クリティカル耐性 (0-999) ※プリセット敵情報では0、ユーザーが調整可能
  requiredHIT: number          // 必要HIT (0-9999) ※プリセット敵情報では0、ユーザーが調整可能
}

type EnemyCategory = 'mob' | 'fieldBoss' | 'boss' | 'raidBoss'
```

#### 5.1.6 mainWeapon装備の武器ステータス仕様

mainWeaponカテゴリの装備では、`weaponStats`フィールドで武器の基本ステータスを定義できます：

- **設定あり**: 装備データで定義された値を使用
- **設定なし**: WeaponFormで入力された値を使用
- **優先度**: `weaponStats` > WeaponForm入力値

```typescript
// 例：武器ステータスが設定された装備
{
  "id": "legendary_sword",
  "name": "レジェンダリーソード",
  "weaponStats": {
    "ATK": 500,
    "stability": 90,
    "refinement": 15
  },
  "properties": {
    "ATK_Rate": 20,
    "Critical_Rate": 15
  }
}

// 例：武器ステータスが未設定の装備（WeaponFormの値を使用）
{
  "id": "basic_sword",
  "name": "ベーシックソード",
  "properties": {
    "ATK%": 10 
  }
}
```

### 5.4 料理データベース構造

#### 5.4.1 料理システム設計

**料理の概念**:
- 料理は5枠のスロットシステム
- 各スロットに異なる料理を設定可能
- 各料理に1-10のレベル設定（「なし」を除く）
- バフ効果はレベルに応じて強度が変化

#### 5.4.2 料理データ構造

**FoodFormDataインターフェース**:
```typescript
interface FoodFormData {
  slot1: FoodSlotData
  slot2: FoodSlotData
  slot3: FoodSlotData
  slot4: FoodSlotData
  slot5: FoodSlotData
}

interface FoodSlotData {
  selectedFood: FoodType    // 選択された料理タイプ
  level: number            // 料理レベル (1-10、「なし」の場合は0)
}

type FoodType = 
  | 'none'                    // なし
  | 'okaka_onigiri'          // おかかおにぎり(STR)
  | 'sake_onigiri'           // 鮭おにぎり(DEX)
  | 'umeboshi_onigiri'       // 梅干しおにぎり(INT)
  | 'mentaiko_onigiri'       // 明太子おにぎり(AGI)
  | 'tuna_mayo_onigiri'      // ツナマヨおにぎり(VIT)
  | 'shoyu_ramen'            // しょうゆラーメン(命中)
  | 'zokusei_pasta'          // 属性パスタ(属性有利共通)
  | 'takoyaki'               // たこ焼き(クリ率)
  | 'yakisoba'               // 焼きそば(攻撃MP回復)
  | 'golden_fried_rice'      // 黄金チャーハン(HP)
  | 'ankake_fried_rice'      // あんかけチャーハン(MP)
  | 'margherita_pizza'       // マルゲリータピザ(武器ATK+)
  | 'diabola_pizza'          // ディアボラピザ(ATK+)
  | 'seafood_pizza'          // シーフードピザ(MATK+)
  | 'beef_stew'              // ビーフシチュー(ヘイト+)
  | 'white_stew'             // ホワイトシチュー(ヘイト-)
  | 'beef_burger'            // ビーフバーガー(物理耐性)
  | 'fish_burger'            // フィッシュバーガー(魔法耐性)
```

#### 5.4.3 料理効果システム（将来実装予定）

**料理効果の概念**:
- 各料理にはゲーム内で定義された効果が存在
- レベル1-10に応じて効果値が変化
- 実際の効果値計算は後のフェーズで実装予定

#### 5.4.4 料理システムバリデーション

**Zodスキーマ定義**:
```typescript
export const foodSlotSchema = z.object({
  selectedFood: z.string(),
  level: z.number()
    .min(0, 'レベルは0以上である必要があります')
    .max(10, 'レベルは10以下である必要があります')
    .refine((value, ctx) => {
      // 「なし」が選択されている場合はレベルは0でなければならない
      const selectedFood = ctx.parent?.selectedFood
      if (selectedFood === 'none' && value !== 0) {
        return false
      }
      // 「なし」以外が選択されている場合はレベルは1-10でなければならない
      if (selectedFood !== 'none' && (value < 1 || value > 10)) {
        return false
      }
      return true
    }, 'レベルが料理選択と矛盾しています')
})

export const foodFormSchema = z.object({
  slot1: foodSlotSchema,
  slot2: foodSlotSchema,
  slot3: foodSlotSchema,
  slot4: foodSlotSchema,
  slot5: foodSlotSchema
})

export type FoodFormData = z.infer<typeof foodFormSchema>
```

#### 5.4.5 料理システムUI仕様

**料理選択UI**:
- 5つの料理スロットを表示
- 各スロットでselectドロップダウンによる料理選択
- 料理選択後、レベル設定用の数値入力フィールド表示
- 「なし」選択時はレベル入力フィールドを非表示

**レベル入力仕様**:
- 数値入力フィールド（1-10の範囲制限）
- レベル変更時のリアルタイムバリデーション

#### 5.4.6 デフォルト値

```typescript
const getDefaultFood = (): FoodFormData => ({
  slot1: { selectedFood: 'none', level: 0 },
  slot2: { selectedFood: 'none', level: 0 },
  slot3: { selectedFood: 'none', level: 0 },
  slot4: { selectedFood: 'none', level: 0 },
  slot5: { selectedFood: 'none', level: 0 }
})
```

### 5.5 バフスキルシステム構造

#### 5.5.1 バフスキルデータ型定義

```typescript
interface BuffSkillFormData {
  skills: BuffSkill[]
}

interface BuffSkill {
  id: string                    // スキル識別子
  name: string                  // スキル名
  category: BuffSkillCategory   // スキル系統
  isEnabled: boolean            // オン/オフ状態
  parameters: BuffSkillParameters  // パラメータ設定
}

interface BuffSkillParameters {
  skillLevel?: number      // スキルレベル（1-10）
  stackCount?: number      // 重ねがけ数（トルネードランス等）
  playerCount?: number     // プレイヤー数（ナイトプレッジ等）
  refinement?: number      // 精錬値（ナイトプレッジ等）
  spUsed?: number         // 使用SP（エターナルナイトメア等）
  isCaster?: number       // 使用者フラグ（ブレイブ等）
}

type BuffSkillCategory = 
  | 'mastery' | 'blade' | 'shoot' | 'halberd' | 'mononofu'
  | 'dualSword' | 'sprite' | 'darkPower' | 'shield' | 'knight'
  | 'hunter' | 'assassin' | 'ninja' | 'support' | 'survival'
  | 'battle' | 'pet' | 'minstrel' | 'partisan'
```

#### 5.5.2 バフスキルシステム設計

**UI構成**:
- 19のスキル系統別にセクション分割
- 各セクションは折りたたみ可能
- スキルごとにオン/オフスイッチ + パラメータ入力
- リアルタイムバリデーションとエラー表示

**データ管理**:
- セーブデータに各スキルの設定状態を保存
- Zustand CalculatorStoreで状態管理
- React Hook Formとの統合による型安全な操作

**バリデーション**:
```typescript
export const buffSkillSchema = z.object({
  skills: z.array(z.object({
    id: z.string(),
    name: z.string(),
    category: z.enum(['mastery', 'blade', /* ... */]),
    isEnabled: z.boolean(),
    parameters: z.object({
      skillLevel: z.number().min(1).max(10).optional(),
      stackCount: z.number().min(1).max(10).optional(),
      playerCount: z.number().min(0).max(4).optional(),
      refinement: z.number().min(1).max(15).optional(),
      spUsed: z.number().min(25).max(80).optional(),
      isCaster: z.number().min(0).max(1).optional(),
    })
  }))
})
```

#### 5.5.3 デフォルト値

```typescript
const getDefaultBuffSkills = (): BuffSkillFormData => ({
  skills: [
    // 全58種類のバフスキル（詳細はbuff-skill.mdを参照）
    // 全てisEnabled: false、パラメータは最小値で初期化
  ]
})
```

### 5.6 データ管理パターン

#### 5.6.1 初期化・プリセットデータコピー処理
```typescript
// プリセットデータの初期化処理
async function initializePresetData(): Promise<void> {
  // 装備プリセットデータのコピー
  await copyPresetEquipmentsToLocalStorage()
  
  // クリスタルプリセットデータのコピー
  await copyPresetCrystalsToLocalStorage()
  
  // 敵情報プリセットデータのコピー
  await copyPresetEnemiesToLocalStorage()
}

// プリセットデータコピー関数
async function copyPresetEquipmentsToLocalStorage(): Promise<void>
async function copyPresetCrystalsToLocalStorage(): Promise<void>
async function copyPresetEnemiesToLocalStorage(): Promise<void>
```

#### 5.6.2 データアクセス層（統合済み）
```typescript
// 装備データ取得（プリセット+カスタム統合）
function getAllEquipments(): Equipment[]
function getEquipmentsByCategory(category: EquipmentCategory): Equipment[]
function getEquipmentById(id: string): Equipment | null

// クリスタルデータ取得（プリセット+カスタム統合）
function getAllCrystals(): Crystal[]
function getCrystalsByType(type: CrystalType): Crystal[]
function getCrystalById(id: string): Crystal | null

// 敵情報データ取得（プリセット+カスタム統合）
function getAllEnemies(): Enemy[]
function getEnemiesByCategory(category: EnemyCategory): Enemy[]
function getEnemyById(id: string): Enemy | null

// お気に入り管理
function toggleEquipmentFavorite(id: string): void
function toggleCrystalFavorite(id: string): void
function toggleEnemyFavorite(id: string): void

// データ更新（プリセット由来データも編集可能）
function updateEquipment(id: string, updates: Partial<Equipment>): void
function updateCrystal(id: string, updates: Partial<Crystal>): void
function updateEnemy(id: string, updates: Partial<Enemy>): void

// カスタムデータ作成
function createCustomEquipment(equipment: Omit<Equipment, 'isPreset' | 'createdAt' | 'updatedAt'>): void
function createCustomCrystal(crystal: Omit<Crystal, 'isPreset' | 'createdAt' | 'updatedAt'>): void
function createCustomEnemy(enemy: Omit<Enemy, 'isPreset' | 'createdAt' | 'updatedAt'>): void

// クリスタル取得（装備カテゴリ対応）
function getAvailableCrystalsForEquipment(equipmentCategory: EquipmentCategory): Crystal[]
// mainWeapon: weapon + normal
// body: armor + normal
// additional: additional + normal 
// special: special + normal
// その他の装備カテゴリ: 空配列
```

#### 5.4.3 データバリデーション
- 全ての数値フィールドに適切な範囲制限
- 必須フィールドの検証
- 一意性制約（ID重複チェック）
- プロパティ値の型安全性保証

### 5.5 武器組み合わせシステム

#### 5.5.1 武器種定義

**拡張WeaponType型定義**:
```typescript
export type WeaponType =
  | '片手剣'
  | '双剣'
  | '両手剣'
  | '手甲'
  | '旋風槍'
  | '抜刀剣'
  | '弓'
  | '自動弓'
  | '杖'
  | '魔導具'
  | '素手'

export type SubWeaponType = 
  | 'ナイフ' 
  | '矢' 
  | '盾'
  | '魔道具'
  | '手甲'
  | '巻物'
  | '片手剣'
  | '抜刀剣'
  | 'なし'
```

#### 5.5.2 武器組み合わせテーブル

**メイン武器→サブ武器対応マップ**:
```typescript
export const WEAPON_COMBINATIONS: Record<WeaponType, SubWeaponType[]> = {
  '素手': ['ナイフ', '矢', '盾', '魔道具', '手甲', '巻物', 'なし'],
  '片手剣': ['ナイフ', '矢', '盾', '魔道具', '手甲', '巻物', 'なし'],
  '双剣': ['片手剣'], // 固定、なし選択不可
  '両手剣': ['なし'], // 固定、他選択不可
  '手甲': ['ナイフ', '矢', '盾', '魔道具', 'なし'],
  '旋風槍': ['ナイフ', '矢', 'なし'],
  '抜刀剣': ['ナイフ', '巻物', 'なし'],
  '弓': ['矢', '抜刀剣', 'なし'],
  '自動弓': ['ナイフ', '矢', '盾', '魔道具', '手甲', 'なし'],
  '杖': ['ナイフ', '矢', '盾', '魔道具', '手甲', '巻物', 'なし'],
  '魔導具': ['巻物', 'なし']
}
```

#### 5.5.3 武器組み合わせバリデーション

**バリデーション関数**:
```typescript
// 指定されたメイン武器で選択可能なサブ武器種を取得
export function getAvailableSubWeaponTypes(mainWeaponType: WeaponType): SubWeaponType[] {
  return WEAPON_COMBINATIONS[mainWeaponType] || ['なし']
}

// 武器組み合わせが有効かチェック
export function isValidWeaponCombination(
  mainWeaponType: WeaponType, 
  subWeaponType: SubWeaponType
): boolean {
  const availableSubWeapons = getAvailableSubWeaponTypes(mainWeaponType)
  return availableSubWeapons.includes(subWeaponType)
}

// 無効な組み合わせの場合の自動修正
export function getAutoFixedSubWeapon(mainWeaponType: WeaponType): SubWeaponType {
  const availableSubWeapons = getAvailableSubWeaponTypes(mainWeaponType)
  
  // 双剣の場合は片手剣固定
  if (mainWeaponType === '双剣') {
    return '片手剣'
  }
  
  // 両手剣の場合はなし固定
  if (mainWeaponType === '両手剣') {
    return 'なし'
  }
  
  // その他の場合は「なし」を選択（「なし」が選択肢にない場合は最初の選択肢）
  return availableSubWeapons.includes('なし') ? 'なし' : availableSubWeapons[0]
}
```

#### 5.5.4 武器フォームUI統合

**WeaponFormコンポーネント連携**:
```typescript
// メイン武器変更時の処理
const handleMainWeaponChange = (newWeaponType: WeaponType) => {
  const currentSubWeapon = subWeapon.weaponType
  
  // 現在のサブ武器が新しいメイン武器で選択可能かチェック
  if (!isValidWeaponCombination(newWeaponType, currentSubWeapon)) {
    // 無効な場合は自動修正
    const fixedSubWeapon = getAutoFixedSubWeapon(newWeaponType)
    
    // メイン武器とサブ武器を同時更新
    updateMainWeapon({ ...mainWeapon, weaponType: newWeaponType })
    updateSubWeapon({ ...subWeapon, weaponType: fixedSubWeapon })
  } else {
    // 有効な場合はメイン武器のみ更新
    updateMainWeapon({ ...mainWeapon, weaponType: newWeaponType })
  }
}
```

#### 5.5.5 精錬値表示システム

**精錬値型定義**:
```typescript
export type RefinementDisplay = 
  | '未精錬'
  | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
  | 'E' | 'D' | 'C' | 'B' | 'A' | 'S'

export type RefinementValue = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15
```

**精錬値変換マップ**:
```typescript
export const REFINEMENT_DISPLAY_MAP: Record<RefinementDisplay, RefinementValue> = {
  '未精錬': 0,
  '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9,
  'E': 10, 'D': 11, 'C': 12, 'B': 13, 'A': 14, 'S': 15
}

export const REFINEMENT_VALUE_MAP: Record<RefinementValue, RefinementDisplay> = {
  0: '未精錬',
  1: '1', 2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7', 8: '8', 9: '9',
  10: 'E', 11: 'D', 12: 'C', 13: 'B', 14: 'A', 15: 'S'
}
```

**精錬値変換関数**:
```typescript
// 表示形式から内部計算値への変換
export function refinementDisplayToValue(display: RefinementDisplay): RefinementValue {
  return REFINEMENT_DISPLAY_MAP[display]
}

// 内部計算値から表示形式への変換
export function refinementValueToDisplay(value: RefinementValue): RefinementDisplay {
  return REFINEMENT_VALUE_MAP[value]
}

// 選択可能な精錬値リストを取得
export function getRefinementDisplayOptions(): RefinementDisplay[] {
  return ['未精錬', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'E', 'D', 'C', 'B', 'A', 'S']
}
```

**武器インターフェース更新**:
```typescript
export interface MainWeapon {
  weaponType: WeaponType
  ATK: number
  stability: number
  refinement: RefinementValue // 内部計算用（0-15）
}

export interface SubWeapon {
  weaponType: SubWeaponType
  ATK: number
  stability: number
  refinement: RefinementValue // 内部計算用（0-15）
}

// UI表示用の武器データ
export interface WeaponFormDisplay {
  weaponType: string
  ATK: number
  stability: number
  refinementDisplay: RefinementDisplay // UI表示用
}
```

#### 5.5.6 Zodバリデーションスキーマ

**精錬値バリデーション**:
```typescript
export const refinementDisplaySchema = z.enum([
  '未精錬', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'E', 'D', 'C', 'B', 'A', 'S'
])

export const refinementValueSchema = z.number().min(0).max(15)
```

**武器組み合わせバリデーション**:
```typescript
export const weaponCombinationSchema = z.object({
  mainWeapon: z.object({
    weaponType: z.enum([...WeaponTypeArray]),
    ATK: z.number().min(0).max(1500),
    stability: z.number().min(0).max(100),
    refinement: refinementValueSchema
  }),
  subWeapon: z.object({
    weaponType: z.enum([...SubWeaponTypeArray]),
    ATK: z.number().min(0).max(1500),
    stability: z.number().min(0).max(100),
    refinement: refinementValueSchema
  })
}).refine((data) => {
  return isValidWeaponCombination(data.mainWeapon.weaponType, data.subWeapon.weaponType)
}, {
  message: "選択されたメイン武器とサブ武器の組み合わせは無効です",
  path: ["subWeapon", "weaponType"]
})

// UI用フォームスキーマ
export const weaponFormDisplaySchema = z.object({
  mainWeapon: z.object({
    weaponType: z.enum([...WeaponTypeArray]),
    ATK: z.number().min(0).max(1500),
    stability: z.number().min(0).max(100),
    refinementDisplay: refinementDisplaySchema
  }),
  subWeapon: z.object({
    weaponType: z.enum([...SubWeaponTypeArray]),
    ATK: z.number().min(0).max(1500),
    stability: z.number().min(0).max(100),
    refinementDisplay: refinementDisplaySchema
  })
})
```

### 5.6 バフスキルシステム構造

#### 5.6.1 バフスキルデータ型

**基本インターフェース**:
```typescript
interface BuffSkill {
  id: string                      // スキル識別子
  name: string                    // スキル名（日本語表示用）
  category: BuffSkillCategory     // スキル系統
  isEnabled: boolean              // オン/オフ状態
  parameters: BuffSkillParameters // パラメータ設定
}

interface BuffSkillParameters {
  skillLevel?: number      // スキルレベル（1-10）
  stackCount?: number      // 重ねがけ数（トルネードランス等）
  playerCount?: number     // プレイヤー数（ナイトプレッジ等）
  refinement?: number      // 精錬値（ナイトプレッジ等）
  spUsed?: number         // 使用SP（エターナルナイトメア等）
  isCaster?: number       // 使用者フラグ（ブレイブ等: 0=他者使用, 1=自己使用）
}

type BuffSkillCategory = 
  | 'mastery' | 'blade' | 'shoot' | 'halberd' | 'mononofu'
  | 'dualSword' | 'sprite' | 'darkPower' | 'shield' | 'knight'
  | 'hunter' | 'assassin' | 'ninja' | 'support' | 'survival'
  | 'battle' | 'pet' | 'minstrel' | 'partisan'
```

#### 5.5.2 武器種連動マスタリスキル表示

**マッピング定義**:
```typescript
const weaponTypeToMasterySkills: Record<WeaponType, string[]> = {
  '素手': ['shield_mastery'],
  '片手剣': ['blade_mastery', 'shield_mastery'],
  '双剣': ['blade_mastery', 'dual_mastery'],
  '両手剣': ['blade_mastery'],
  '手甲': ['martial_mastery', 'shield_mastery'],
  '旋風槍': ['halberd_mastery'],
  '抜刀剣': [], // 該当するマスタリスキルなし
  '弓': ['shoot_mastery'],
  '自動弓': ['shoot_mastery', 'shield_mastery'],
  '杖': ['magic_mastery', 'shield_mastery'],
  '魔導具': ['magic_mastery'],
}

// 武器種から専用スキルIDを取得するマッピング
const weaponTypeToSpecialSkills: Record<WeaponType, string[]> = {
  '素手': [],
  '片手剣': [],
  '双剣': [],
  '両手剣': [],
  '手甲': [],
  '旋風槍': ['thor_hammer', 'tornado_lance', 'critical_parry'], // トールハンマー、トルネードランス、会心の捌き
  '抜刀剣': [],
  '弓': [],
  '自動弓': [],
  '杖': [],
  '魔導具': [],
}
```

**表示制御ロジック**:
- 武器種変更時に動的にマスタリスキル・専用スキル表示を更新
- **武器種変更時に全てのマスタリスキル・専用スキル設定がリセットされる**
- UI上では該当しないマスタリスキル・専用スキルは完全非表示
- 抜刀剣の場合はマスタリスキル系統全体が非表示
- グリッドレイアウトでの平坦表示（カテゴリ別折りたたみなし）

**武器種変更時の処理フロー**:
```typescript
// 1. 武器種変更検知
useEffect(() => {
  if (prevWeaponType.current !== mainWeaponType) {
    // 2. 全マスタリスキル・専用スキルをリセット
    resetWeaponDependentSkillsOnWeaponChange(mainWeaponType)
    prevWeaponType.current = mainWeaponType
  }
}, [mainWeaponType])

// 3. マスタリスキル・専用スキルリセット処理
const resetWeaponDependentSkillsOnWeaponChange = (newWeaponType: WeaponType) => {
  const weaponSpecificSkillIds = ['thor_hammer', 'tornado_lance', 'critical_parry'] // 旋風槍専用スキル
  
  const updatedSkills = skills.map(skill => {
    if (skill.category === 'mastery' || weaponSpecificSkillIds.includes(skill.id)) {
      return {
        ...skill,
        isEnabled: false,
        parameters: getDefaultParametersForSkill(skill.id)
      }
    }
    return skill
  })
  updateBuffSkills({ skills: updatedSkills })
}
```

#### 5.5.3 バフスキルUI仕様（ポップオーバー対応）

**基本レイアウト**:
- 5カラムグリッドレイアウト（レスポンシブ対応）
- スキルカード形式での表示
- カテゴリラベル付きフラット表示（折りたたみなし）

**操作フロー**:
1. 有効・無効ボタンでスキルの状態を切り替え
2. スキル名をクリックでポップオーバー表示
3. ポップオーバー内でパラメータ編集
4. 適用/キャンセルボタンで変更確定

**有効・無効ボタンUI仕様**:
```typescript
// 2つのボタンによる状態切り替え
interface SkillToggleButtonsProps {
  isEnabled: boolean
  onToggle: (enabled: boolean) => void
  className?: string
}

// 有効ボタン:
//   - アクティブ時: bg-green-600 text-white shadow-md
//   - 非アクティブ時: bg-gray-200 text-gray-600 hover:bg-gray-300
// 無効ボタン:
//   - アクティブ時: bg-red-600 text-white shadow-md  
//   - 非アクティブ時: bg-gray-200 text-gray-600 hover:bg-gray-300
```

**スキル名表示形式**:
- 設定済みパラメータを併記（例: `ハルバードマスタリ/10`）
- 未設定時は基本名のみ表示

**ポップオーバー仕様**:
```typescript
interface SkillPopoverProps {
  skill: BuffSkill
  onParameterChange: (skillId: string, parameters: BuffSkillParameters) => void
  onClose: () => void
}
```

**特殊パラメータスキル**:
- **エターナルナイトメア**: 
  - `skillLevel` (1-10) + `spUsed` (25-80)
  - 表示形式: `エターナルナイトメア/10(SP:80)`
- **ナイトプレッジ**: 
  - `skillLevel` (1-10) + `playerCount` (0-4) + `refinement` (1-15)
  - 表示形式: `ナイトプレッジ/10`
- **ブレイブ**: 
  - `isCaster` (0: 他者使用, 1: 自己使用)
  - 表示形式: `ブレイブ` (基本名のみ)
- **情熱の歌**:
  - `stackCount` (1-10)
  - 表示形式: `情熱の歌(5)` (重ねがけ数表示)
- **神速の捌手**:
  - `stackCount` (1-3) 
  - 表示形式: `神速の捌手(2)` (重ねがけ回数表示)

**パラメータ編集フォーム**:
```typescript
// エターナルナイトメア専用フォーム
interface EternalNightmareForm {
  skillLevel: number  // 1-10
  spUsed: number      // 25-80
}

// ナイトプレッジ専用フォーム  
interface KnightPledgeForm {
  skillLevel: number   // 1-10
  playerCount: number  // 0-4
  refinement: number   // 1-15
}

// ブレイブ専用フォーム
interface BraveForm {
  isCaster: number     // 0 or 1
}
```

#### 5.5.4 Zodバリデーション

```typescript
const buffSkillParametersSchema = z.object({
  skillLevel: z.number().min(1).max(10).optional(),
  stackCount: z.number().min(1).max(10).optional(),
  playerCount: z.number().min(0).max(4).optional(),
  refinement: z.number().min(1).max(15).optional(),
  spUsed: z.number().min(25).max(80).optional(),
  isCaster: z.number().min(0).max(1).optional(),
})

const buffSkillSchema = z.object({
  id: z.string().min(1),
  name: z.string().min(1),
  category: buffSkillCategorySchema,
  isEnabled: z.boolean(),
  parameters: buffSkillParametersSchema,
})
```

### 5.6 バフアイテムデータベース構造

#### 5.6.1 ファイル構成・データフロー
**初期データ配置**:
- **プリセットデータ**: `src/data/buffItems.json`（静的ファイル）

**アプリ起動時の処理**:
```
アプリ起動 → プリセットJSONを読み込み → LocalStorageにコピー → 以降はLocalStorageから参照
```

**ローカルストレージキー**:
- **プリセットバフアイテム（コピー済み）**: LocalStorage (`preset_buff_items`)
- **ユーザーカスタム不可**: システム提供アイテムのみ使用

#### 5.6.2 JSON構造

```json
{
  "buffItems": {
    "physicalPower": [バフアイテム配列],
    "magicalPower": [バフアイテム配列],
    "physicalDefense": [バフアイテム配列],
    "magicalDefense": [バフアイテム配列],
    "elementalAttack": [バフアイテム配列],
    "elementalDefense": [バフアイテム配列],
    "speed": [バフアイテム配列],
    "casting": [バフアイテム配列],
    "mp": [バフアイテム配列],
    "hp": [バフアイテム配列],
    "accuracy": [バフアイテム配列],
    "evasion": [バフアイテム配列]
  }
}
```

#### 5.6.3 バフアイテム構造

**プリセットバフアイテムインターフェース**:
```typescript
interface PresetBuffItem {
  id: string                           // 一意識別子
  name: string                         // アイテム名
  category: BuffItemCategory           // カテゴリ
  properties: Partial<EquipmentProperties>  // 装備と同一のプロパティ構造
}

type BuffItemCategory = 
  | 'physicalPower'    // 物理威力
  | 'magicalPower'     // 魔法威力
  | 'physicalDefense'  // 物理防御
  | 'magicalDefense'   // 魔法防御
  | 'elementalAttack'  // 属性攻撃
  | 'elementalDefense' // 属性防御
  | 'speed'            // 速度
  | 'casting'          // 詠唱
  | 'mp'               // MP
  | 'hp'               // HP
  | 'accuracy'         // 命中
  | 'evasion'          // 回避
```

**ローカルストレージバフアイテムインターフェース**:
```typescript
interface LocalStorageBuffItem extends PresetBuffItem {
  isPreset: boolean            // プリセット由来かどうか（常にtrue）
  isFavorite: boolean          // お気に入り設定
  createdAt: string           // 作成日時 (ISO string)
  updatedAt: string           // 更新日時 (ISO string)
}

// 統合型（アプリ内で使用するバフアイテムデータ型）
type BuffItem = LocalStorageBuffItem
```

#### 5.6.4 バフアイテムフォームデータ構造

**BuffItemFormDataインターフェース**:
```typescript
interface BuffItemFormData {
  physicalPower: string | null       // 選択されたアイテムID（null = なし）
  magicalPower: string | null
  physicalDefense: string | null
  magicalDefense: string | null
  elementalAttack: string | null
  elementalDefense: string | null
  speed: string | null
  casting: string | null
  mp: string | null
  hp: string | null
  accuracy: string | null
  evasion: string | null
}
```

#### 5.6.5 Zodバリデーション

```typescript
const buffItemFormDataSchema = z.object({
  physicalPower: z.string().nullable(),
  magicalPower: z.string().nullable(),
  physicalDefense: z.string().nullable(),
  magicalDefense: z.string().nullable(),
  elementalAttack: z.string().nullable(),
  elementalDefense: z.string().nullable(),
  speed: z.string().nullable(),
  casting: z.string().nullable(),
  mp: z.string().nullable(),
  hp: z.string().nullable(),
  accuracy: z.string().nullable(),
  evasion: z.string().nullable(),
})
```

## 6. UI仕様

### 6.1 装備カスタム機能UI

**全装備スロットカスタム操作**
- **対象スロット**: メイン装備、体装備、追加装備、特殊装備、サブ武器、オシャレ1、オシャレ2、オシャレ3（全8スロット）
- 装備選択UI内にカスタム機能を統合配置
- プリセット選択ボタンの右に「新規作成」ボタン配置
- 新規作成ボタンの右に「名前変更」ボタン配置（カスタム装備選択時のみ表示）
- 名前変更ボタンの右に「削除」ボタン配置（カスタム装備選択時のみ表示）
- プリセット装備選択時は名前変更・削除ボタンを非表示（誤操作防止）

**新規作成機能**
```typescript
interface CreateEquipmentModalProps {
  isOpen: boolean
  onClose: () => void
  onConfirm: (equipmentName: string) => void
  equipmentType: string  // 装備カテゴリに対応する表示名
}
```

**名前変更機能**
```typescript
interface RenameEquipmentModalProps {
  isOpen: boolean
  onClose: () => void
  onConfirm: (newName: string) => void
  currentName: string
  equipmentId: string
}
```

**削除確認機能**
```typescript
interface DeleteConfirmModalProps {
  isOpen: boolean
  onClose: () => void
  onConfirm: () => void
  equipmentName: string
  message: string
}
```

**カスタム装備ボタン表示条件**
```typescript
// 名前変更・削除ボタンの表示判定（全装備スロット共通）
const showCustomEquipmentButtons = (slotKey: keyof EquipmentSlots) => (
  effectiveEquipment[slotKey].id && 
  'isCustom' in effectiveEquipment[slotKey] && 
  effectiveEquipment[slotKey].isCustom
)

// 各スロットでの表示制御
const showRenameButton = (slotKey: keyof EquipmentSlots) => 
  showCustomEquipmentButtons(slotKey)

const showDeleteButton = (slotKey: keyof EquipmentSlots) => 
  showCustomEquipmentButtons(slotKey)

// 新規作成ボタンは全スロットで常時表示
const showCreateButton = true  // 全装備スロットで表示
```

**UI動作仕様（全装備スロット対応）**
- **新規作成クリック** → 装備名入力モーダル表示 → 装備カテゴリに応じた初期名設定 → 入力確定でカスタム装備作成 → 自動的に該当装備スロットにセット
- **名前変更クリック** → 名前変更モーダル表示 → 現在名を初期値として設定 → 新しい名前入力 → 確定で名前更新（カスタム装備のみ）
- **削除クリック** → 削除確認モーダル表示 → 装備名と装備カテゴリを表示 → 確定でカスタム装備を削除（カスタム装備のみ）
- **プリセット装備選択時** → 名前変更・削除ボタン非表示（システム装備保護）
- **プリセット選択モーダル** → カスタム装備も選択可能（装備カテゴリ別にフィルタリング、統合表示）
- **カスタム装備識別** → 視覚的に区別表示（アイコン、ラベル等）
- **武器系装備特別対応** → メイン装備・サブ武器では武器ステータス（ATK、安定率、精錬値）も初期化

**カスタム装備保存管理システム**
- 編集セッション管理：カスタム装備のプロパティ編集時は編集セッションを作成し、永続データとは分離して管理
- セーブ時永続化：「現在のデータを保存」実行時のみ編集内容をLocalStorageに永続保存
- 編集破棄機能：保存せずにセーブデータ切り替え・ブラウザリロード時は編集セッションを削除し、永続データを復元
- 保存状態表示：編集中カスタム装備の視覚的インジケーター（オレンジ色警告表示）

**カスタム装備プロパティ連動システム**
- 編集セッション連動：カスタム装備セット中のプロパティ入力変更を編集セッションに記録
- フォーム値優先：プロパティフォームは編集セッション値を優先表示、永続データは変更しない
- 装備選択UI連動：装備選択モーダルも編集セッション値を反映表示
- データ整合性：永続データと編集セッションデータを明確に分離管理

**カスタム装備統合仕様**
```typescript
interface EquipmentSelectionModalProps {
  isOpen: boolean
  onClose: () => void
  onSelect: (equipmentId: string | null) => void
  selectedEquipmentId: string | null
  category: EquipmentCategory
  title: string
  includeCustomEquipments?: boolean // カスタム装備を含むかどうか
}

// 統合装備データ構造
interface CombinedEquipmentData {
  presetEquipments: PresetEquipment[]
  customEquipments: UserEquipment[]
  totalCount: number
}

// カスタム装備編集セッション管理
interface CustomEquipmentEditSession {
  equipmentId: string                               // 編集対象装備ID
  originalData: UserEquipment                       // 永続データ（元の値）
  editedData: UserEquipment                         // 編集中データ
  isModified: boolean                               // 編集有無フラグ
  startedAt: string                                 // 編集開始日時
  lastModified: string                              // 最終変更日時
}

// カスタム装備状態管理
interface CustomEquipmentState {
  isTemporary: boolean        // 新規作成の仮データかどうか
  hasEditSession: boolean     // 編集セッション中かどうか
  needsSaving: boolean        // 保存が必要かどうか
  lastModified: string        // 最終更新日時
}

// プロパティ表示制御
interface PropertyDisplayConfig {
  useEditedValues: boolean    // 編集値を優先表示するか
  showOriginalValues: boolean // 元の値も表示するか
  highlightChanges: boolean   // 変更箇所をハイライトするか
}
```

**カスタム装備データフロー（改善版）**
```
【新規作成フロー】
新規作成 → 仮データ作成（メモリ） → プロパティ編集 → 仮データ更新
                                              ↓
セーブ実行 → LocalStorage永続化 ← 現在のデータを保存
           → 仮データ削除

【既存装備編集フロー】  
カスタム装備選択 → 永続データ読み込み → プロパティ編集開始
                                              ↓
プロパティ変更 → 編集セッション作成 → 編集データ更新（永続データは不変）
                                              ↓
セーブ実行 → 編集データを永続データに反映 → 編集セッション削除

【編集破棄フロー】
リロード/セーブデータ切り替え → 編集セッション削除 → 永続データ復元
```

**プロパティ連動フロー（改善版）**
```
プロパティフォーム表示 → 編集セッション値を優先表示
                              ↓
プロパティフォーム変更 → カスタム装備判定 → 編集セッション更新
                                    ↓
装備選択モーダル → 編集セッション値を反映表示
```

**具体例：ATK変更フロー**
```
1. カスタム武器ATK=5で保存済み（永続データ：ATK=5）
2. 武器を選択 → フォーム表示：ATK=5
3. ATK=10に変更 → 編集セッション作成：{セーブID:装備ID, 原本:ATK=5, 編集中:ATK=10}
4. 装備選択UI → ATK=10表示（編集中値を反映）
5a. 保存実行 → 永続データATK=10に更新 → 編集セッション削除
5b. リロード/切り替え → 編集セッション削除 → フォーム復元：ATK=5
```

**セーブデータ固有の編集セッション管理**
```
編集セッションキー形式：${saveDataId}:${equipmentId}
例：
- セーブ1の武器A → "save1:weaponA"
- セーブ2の武器A → "save2:weaponA"
- メインデータの武器A → "default:weaponA"

セーブデータ切り替え時：
1. 新しいセーブデータID設定
2. 前のセーブデータの編集セッション削除
3. 新しいセーブデータのデータ読み込み
```

### 6.3 バフアイテム選択UI

**選択方式**
- モーダル選択方式での選択（装備・クリスタ選択UIと統一されたデザイン）
- 各カテゴリごとに選択ボタンをクリックしてモーダル表示
- オーバーレイモーダル方式でのアイテム選択画面
- グリッドレイアウトでのバフアイテム一覧表示
- バフアイテムカード形式（名前、カテゴリ、効果プロパティ表示）

**実装仕様**
```typescript
interface BuffItemSelectionModalProps {
  isOpen: boolean
  onClose: () => void
  onSelect: (buffItemId: string | null) => void
  selectedBuffItemId: string | null
  category: BuffItemCategory
  title: string
}

interface BuffItemCardProps {
  buffItem: PresetBuffItem
  isSelected: boolean
  onClick: () => void
}

// バフアイテム選択ボタン
interface BuffItemButtonProps {
  category: BuffItemCategory
  label: string
  selectedItem: PresetBuffItem | null
  onOpenModal: (category: BuffItemCategory) => void
}
```

**UI構成要素**
- **選択ボタン**: 各カテゴリの選択状態表示 + モーダル起動
  - 未選択時: 「なし」表示、グレー背景
  - 選択済み時: アイテム名 + 効果概要表示、青背景
- **選択モーダル**: 
  - ヘッダー: カテゴリ名 + 閉じるボタン
  - アイテムグリッド: 4列グリッドでアイテムカード表示
  - 「なし」オプション: 選択解除用
  - フッター: キャンセルボタン
- **アイテムカード**:
  - カテゴリバッジ（カラーコード付き）
  - アイテム名
  - 効果プロパティ（最大3項目表示）
  - 選択状態チェックマーク

**カテゴリカラーコード**
```typescript
const categoryColors = {
  physicalPower: 'bg-red-100 text-red-800',
  magicalPower: 'bg-purple-100 text-purple-800',
  physicalDefense: 'bg-blue-100 text-blue-800',
  magicalDefense: 'bg-indigo-100 text-indigo-800',
  elementalAttack: 'bg-orange-100 text-orange-800',
  elementalDefense: 'bg-emerald-100 text-emerald-800',
  speed: 'bg-yellow-100 text-yellow-800',
  casting: 'bg-cyan-100 text-cyan-800',
  mp: 'bg-blue-100 text-blue-800',
  hp: 'bg-green-100 text-green-800',
  accuracy: 'bg-amber-100 text-amber-800',
  evasion: 'bg-pink-100 text-pink-800',
}
```

### 6.4 敵情報選択UI

**選択方式**
- モーダル選択形式での敵情報選択（装備・クリスタ選択UIと統一されたデザイン）
- 「敵を選択」ボタンをクリックしてモーダル表示
- フルスクリーンオーバーレイモーダル方式での敵選択画面
- タブ型フィルタリング機能（全て、モブ、フィールドボス、ボス、レイドボス）
- グリッドレイアウトでの敵一覧表示
- 敵カード形式での情報表示（名前、レベル、カテゴリ、基本ステータス）
- 背景クリック・ESCキーでモーダル閉じる
- 選択済み敵の情報をボタン上に表示（名前、レベル、カテゴリ）
- 手動ステータス入力機能との併用（プリセット選択後にクリティカル耐性と必要HITを調整可能）

**実装仕様**
```typescript
interface EnemySelectionModalProps {
  isOpen: boolean
  onClose: () => void
  onSelect: (enemyId: string) => void
  selectedEnemyId: string | null
  title: string
}

interface EnemyCardProps {
  enemy: PresetEnemy
  isSelected: boolean
  onClick: () => void
}

// 敵カテゴリタブ構造
interface EnemyTab {
  id: EnemyCategory | 'all'
  label: string
  count: number
}
```

## 7. フォームバリデーション仕様

### 7.1 基本ステータスバリデーション
```typescript
const baseStatsSchema = z.object({
  STR: z.number().min(1).max(510),
  INT: z.number().min(1).max(510),
  VIT: z.number().min(1).max(510),
  AGI: z.number().min(1).max(510),
  DEX: z.number().min(1).max(510),
  CRT: z.number().min(1).max(255),
  MEN: z.number().min(1).max(255),
  TEC: z.number().min(1).max(255),
  level: z.number().min(1).max(510),
})
```

### 7.2 武器バリデーション
```typescript
const weaponSchema = z.object({
  weaponType: z.string(),
  ATK: z.number().min(0).max(1500),
  stability: z.number().min(0).max(100),
  refinement: z.number().min(0).max(15),
})
```

### 7.3 敵情報バリデーション
```typescript
const enemySchema = z.object({
  level: z.number().min(1).max(999),
  DEF: z.number().min(0).max(9999),
  MDEF: z.number().min(0).max(9999),
  physicalResistance: z.number().min(-100).max(100),
  magicalResistance: z.number().min(-100).max(100),
  resistCritical: z.number().min(0).max(999),    // プリセットでは0、ユーザー調整可能
  requiredHIT: z.number().min(0).max(9999),      // プリセットでは0、ユーザー調整可能
})
```

### 7.4 バフスキルバリデーション

```typescript
const buffSkillFormDataSchema = z.object({
  skills: z.array(buffSkillSchema),
})
```

## 7. セーブデータ管理UI仕様

### 7.1 保存ボタンの統一仕様

**保存ボタンラベル**:
- 統一表記: 「現在のデータを保存」
- 未保存の変更の有無に関わらず同じテキスト表示

**視覚的フィードバック**:
```typescript
// ボタンの色分けによる状態表示
interface SaveButtonProps {
  hasUnsavedChanges: boolean
  onClick: () => void
}

// 未保存の変更あり: bg-orange-600 (オレンジ色)
// 未保存の変更なし: bg-green-600 (緑色)
```

**削除された機能**:
- 従来の「現在のデータを保存」ボタン（重複排除）
- 「未保存の変更を保存」テキスト表記

### 7.2 SaveDataManager UI構成

**メインアクション**:
- 現在のデータを保存ボタン（色で変更状態を表示）
- 新規セーブ作成ボタン
- キャンセルボタン

**セーブデータリスト**:
- 既存セーブデータの一覧表示
- 各アイテムの読み込み・編集・削除機能

## 8. LocalStorage設計

### 8.1 保存データ構造
```typescript
interface LocalStorageData {
  custom_equipments: PresetEquipment[]
  custom_crystals: PresetCrystal[]
  custom_enemies: PresetEnemy[]
  user_settings: UserSettings
  saved_builds: CalculatorData[]
}
```

### 8.2 データ同期パターン
- 読み込み時: プリセット + ユーザーカスタムを統合
- 保存時: ユーザーカスタムデータのみLocalStorageに保存
- エラーハンドリング: try-catchでLocalStorageアクセスエラーを処理

## 8. パフォーマンス最適化

### 8.1 データロード最適化
- 遅延ロード: 必要な装備カテゴリのみロード
- メモ化: 計算結果のキャッシュ
- バーチャルスクロール: 大量アイテム表示時

### 8.2 フォーム最適化
- debounce: 入力値変更の処理遅延
- 分割バリデーション: フィールド単位での検証
- 最適化されたrerender: 不要な再描画を防止

## 9. エラーハンドリング

### 9.1 データ読み込みエラー
- JSONパースエラー処理
- LocalStorageアクセスエラー処理
- フォールバック機能

### 9.2 バリデーションエラー
- リアルタイムエラー表示
- エラーメッセージの国際化対応
- ユーザビリティを考慮したエラー表示

## 10. 将来拡張設計

### 10.1 データ構造拡張
- 新装備カテゴリの追加容易性
- 新プロパティの追加容易性
- バージョン管理対応

### 10.2 機能拡張
- インポート/エクスポート機能
- 装備セット保存機能
- 最適化計算機能
- マルチユーザー対応準備

## 11. 自由入力装備スロット拡張

### 11.1 自由入力スロット追加概要

**目的**: プロパティ試行専用の装備スロットを追加し、ユーザーが自由にプロパティの組み合わせを試せる環境を提供

**追加装備スロット**:
- 自由入力1 (freeInput1)
- 自由入力2 (freeInput2)  
- 自由入力3 (freeInput3)

**装備タブレイアウト変更**:
従来の8装備スロットから11装備スロットに拡張

### 11.2 自由入力スロットの特徴

**制限事項**:
- プリセット装備選択機能なし（プリセット選択ボタン非表示）
- カスタム装備機能のみ対応（新規作成・名前変更・削除）
- 武器ステータス（ATK、安定率、精錬値）は初期化対象外

**利用可能機能**:
- 全プロパティの手動入力（他の装備スロットと同一のプロパティセット）
- カスタム装備の新規作成（装備名入力モーダル、初期値は空文字列）
- カスタム装備の名前変更（選択中のカスタム装備のみ）
- カスタム装備の削除（選択中のカスタム装備のみ）
- プロパティ連動機能（編集中データの仮保存・永続保存）

### 11.3 データ構造の変更

**EquipmentSlotsインターフェース拡張**:
```typescript
interface EquipmentSlots {
  main: Equipment
  body: Equipment
  additional: Equipment
  special: Equipment
  subWeapon: Equipment
  fashion1: Equipment
  fashion2: Equipment
  fashion3: Equipment
  freeInput1: Equipment  // 新規追加
  freeInput2: Equipment  // 新規追加
  freeInput3: Equipment  // 新規追加
}
```

**EquipmentCategoryタイプ拡張**:
```typescript
type EquipmentCategory = 
  | 'main'
  | 'body'
  | 'additional'
  | 'special'
  | 'subWeapon'
  | 'fashion1'
  | 'fashion2'
  | 'fashion3'
  | 'freeInput1'  // 新規追加
  | 'freeInput2'  // 新規追加
  | 'freeInput3'  // 新規追加
```

### 11.4 UI実装仕様

**装備タブ構成**:
```typescript
const equipmentSlots = [
  { key: 'main' as const, label: 'メイン装備' },
  { key: 'body' as const, label: '体装備' },
  { key: 'additional' as const, label: '追加装備' },
  { key: 'special' as const, label: '特殊装備' },
  { key: 'subWeapon' as const, label: 'サブ武器' },
  { key: 'fashion1' as const, label: 'オシャレ1' },
  { key: 'fashion2' as const, label: 'オシャレ2' },
  { key: 'fashion3' as const, label: 'オシャレ3' },
  { key: 'freeInput1' as const, label: '自由入力1' },  // 新規追加
  { key: 'freeInput2' as const, label: '自由入力2' },  // 新規追加
  { key: 'freeInput3' as const, label: '自由入力3' },  // 新規追加
]
```

**タブレイアウト調整**:
- グリッドレイアウトを4列から適切な列数に調整
- レスポンシブ対応（sm: 2列、md: 3列、lg: 4列等）

**自由入力スロットのボタン表示制御**:
```typescript
const showCustomEquipmentButtons = (slotKey: keyof EquipmentSlots) => {
  // 自由入力スロットは常にカスタム機能ボタンを表示
  if (['freeInput1', 'freeInput2', 'freeInput3'].includes(slotKey)) {
    return true
  }
  
  // 通常スロットは既存の判定ロジック
  return (
    effectiveEquipment[slotKey].id && 
    'isCustom' in effectiveEquipment[slotKey] && 
    effectiveEquipment[slotKey].isCustom
  )
}

const showPresetSelectionButton = (slotKey: keyof EquipmentSlots) => {
  // 自由入力スロットはプリセット選択ボタンを非表示
  return !['freeInput1', 'freeInput2', 'freeInput3'].includes(slotKey)
}
```

### 11.5 カテゴリ別初期化処理の調整

**equipmentDatabase.ts の調整**:
```typescript
export function getEquipmentCategoryDisplayName(category: EquipmentCategory): string {
  switch (category) {
    // 既存ケース...
    case 'freeInput1': return '自由入力1'
    case 'freeInput2': return '自由入力2'
    case 'freeInput3': return '自由入力3'
    default: return category
  }
}

export function createCustomEquipment(
  equipmentCategory: EquipmentCategory,
  name: string,
): UserEquipment {
  // 自由入力スロットは武器ステータス初期化対象外
  const isWeaponType = ['main', 'subWeapon'].includes(equipmentCategory)
  
  const customEquipment: UserEquipment = {
    // 基本プロパティ...
    weaponStats: isWeaponType ? {
      ATK: 0,
      stability: 0,
      refinement: 0,
    } : undefined,
    // 自由入力スロットはクリスタルスロット対象外
    crystalSlots: ['main', 'body', 'additional', 'special'].includes(
      equipmentCategory,
    ) ? {
      slot1: undefined,
      slot2: undefined,
    } : undefined,
  }
  
  return customEquipment
}
```

### 11.6 データ管理とバリデーション

**Zodスキーマ更新**:
```typescript
const equipmentSlotsSchema = z.object({
  main: equipmentSchema,
  body: equipmentSchema,
  additional: equipmentSchema,
  special: equipmentSchema,
  subWeapon: equipmentSchema,
  fashion1: equipmentSchema,
  fashion2: equipmentSchema,
  fashion3: equipmentSchema,
  freeInput1: equipmentSchema,  // 新規追加
  freeInput2: equipmentSchema,  // 新規追加
  freeInput3: equipmentSchema,  // 新規追加
})
```

**カスタム装備データ管理**:
- 自由入力スロットのカスタム装備も既存の仕組みで管理
- LocalStorageでの永続化対象
- セーブデータ間での共有対象
- 編集セッション管理対象

### 11.7 プロパティ表示の統一

**全スロット共通プロパティセット**:
自由入力スロットでも既存の装備スロットと同一のプロパティが利用可能：

- 攻撃・威力系（ATK%/+、MATK%/+、武器ATK%/+、貫通系、威力系等）
- ステータス系（HP/MP、STR/INT/VIT/AGI/DEX、命中/回避、速度系等）
- 継戦補助系（MP回復、耐性、ヘイト、自然回復等）
- 戦闘補助系（防御崩し、先読み、Guard系等）
- 低頻度系（ステータス連動攻撃力、属性耐性、ダメージ軽減、バリア/追撃等）

### 11.8 レスポンシブデザイン対応

**タブナビゲーション調整**:
```typescript
<nav className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-2">
  {equipmentSlots.map(({ key, label }) => (
    <button key={key} /* タブボタン実装 */>
      {label}
    </button>
  ))}
</nav>
```

**画面サイズ別表示**:
- モバイル: 2列表示で縦にスクロール
- タブレット: 3-4列表示
- デスクトップ: 6列表示で1行に収納

## 12. レジスタ他システム

### 12.1 レジスタ他システム概要

**目的**: レジスタレットとギルド料理効果を装備/プロパティシステムに統合し、タブナビゲーション内で一元管理

**システム構成**:
- レジスタレット効果（18種類）
- ギルド料理効果（2種類）
- 効果のオン/オフ切り替え機能
- レベル設定機能（項目別に範囲制限）
- 運命共同体の特殊設定（レベル + パーティメンバー数）

### 12.2 タブナビゲーション統合

**タブ配置**:
```typescript
const equipmentSlots = [
  { key: 'main' as const, label: 'メイン装備' },
  { key: 'body' as const, label: '体装備' },
  { key: 'additional' as const, label: '追加装備' },
  { key: 'special' as const, label: '特殊装備' },
  { key: 'subWeapon' as const, label: 'サブ武器' },
  { key: 'fashion1' as const, label: 'オシャレ1' },
  { key: 'fashion2' as const, label: 'オシャレ2' },
  { key: 'fashion3' as const, label: 'オシャレ3' },
  { key: 'register' as const, label: 'レジスタ他' },  // 新規追加位置
  { key: 'freeInput1' as const, label: '自由入力1' },
  { key: 'freeInput2' as const, label: '自由入力2' },
  { key: 'freeInput3' as const, label: '自由入力3' },
]
```

**レスポンシブ対応**:
- 12タブ対応のグリッドレイアウト調整
- 6列表示で2行構成（デスクトップ）
- タブレット・モバイルでの適切な折り返し

### 12.3 データ型定義

**レジスタ他項目の型定義**:
```typescript
// レジスタ効果項目
export interface RegisterEffect {
  id: string
  name: string
  type: 'registlet' | 'guild_food'
  enabled: boolean
  level: number
  maxLevel: number
  // 運命共同体専用フィールド
  partyMembers?: number
  maxPartyMembers?: number
}

// レジスタ他フォームデータ
export interface RegisterFormData {
  // レジスタレット効果（18種類）
  physicalAttackUp: RegisterEffect
  magicalAttackUp: RegisterEffect
  maxHPUp: RegisterEffect
  maxMPUp: RegisterEffect
  accuracyUp: RegisterEffect
  dodgeUp: RegisterEffect
  attackSpeedUp: RegisterEffect
  magicSpeedUp: RegisterEffect
  fatefulCompanionship: RegisterEffect  // 特殊：レベル1固定 + パーティメンバー数
  voidStance: RegisterEffect
  magicArrowPursuit: RegisterEffect
  airSlideCompression: RegisterEffect
  assassinStabEnhancement: RegisterEffect
  resonancePower: RegisterEffect
  resonanceAcceleration: RegisterEffect
  resonanceConcentration: RegisterEffect
  
  // ギルド料理効果（2種類）
  deliciousIngredientTrade: RegisterEffect
  freshFruitTrade: RegisterEffect
}
```

### 12.4 UI実装仕様

**メインレイアウト**:
```typescript
// RegisterForm.tsx
export default function RegisterForm() {
  const [registerData, setRegisterData] = useState<RegisterFormData>()
  const [levelModalState, setLevelModalState] = useState<{
    isOpen: boolean
    effectId: string | null
    currentLevel: number
    maxLevel: number
    partyMembers?: number
  }>()

  return (
    <div className="space-y-3">
      {/* レジスタレット項目リスト */}
      <div className="space-y-2">
        <h3 className="text-lg font-medium text-gray-800">レジスタレット</h3>
        {registletEffects.map((effect) => (
          <RegisterEffectItem 
            key={effect.id}
            effect={effect}
            onToggle={handleToggle}
            onLevelEdit={handleLevelEdit}
          />
        ))}
      </div>
      
      {/* ギルド料理項目リスト */}
      <div className="space-y-2">
        <h3 className="text-lg font-medium text-gray-800">ギルド料理</h3>
        {guildFoodEffects.map((effect) => (
          <RegisterEffectItem 
            key={effect.id}
            effect={effect}
            onToggle={handleToggle}
            onLevelEdit={handleLevelEdit}
          />
        ))}
      </div>
      
      {/* レベル設定モーダル */}
      <RegisterLevelModal 
        isOpen={levelModalState.isOpen}
        effect={getCurrentEffect()}
        onConfirm={handleLevelConfirm}
        onCancel={handleLevelCancel}
      />
    </div>
  )
}
```

**効果項目コンポーネント**:
```typescript
// RegisterEffectItem.tsx
interface RegisterEffectItemProps {
  effect: RegisterEffect
  onToggle: (effectId: string) => void
  onLevelEdit: (effectId: string) => void
}

export default function RegisterEffectItem({ effect, onToggle, onLevelEdit }: RegisterEffectItemProps) {
  return (
    <div className="flex items-center justify-between p-3 border border-gray-200 rounded-lg">
      {/* 効果名とレベル表示 */}
      <button 
        onClick={() => onLevelEdit(effect.id)}
        className="text-left hover:text-blue-600 transition-colors"
      >
        <span className="font-medium">{effect.name}</span>
        <span className="text-gray-500 ml-1">/{effect.level}</span>
        {effect.partyMembers && (
          <span className="text-gray-500 ml-1">({effect.partyMembers}人)</span>
        )}
      </button>
      
      {/* オン/オフトグル */}
      <button
        onClick={() => onToggle(effect.id)}
        className={`px-3 py-1 rounded-md text-sm font-medium transition-colors ${
          effect.enabled 
            ? 'bg-green-500 text-white' 
            : 'bg-gray-300 text-gray-600'
        }`}
      >
        {effect.enabled ? 'ON' : 'OFF'}
      </button>
    </div>
  )
}
```

**レベル設定モーダル**:
```typescript
// RegisterLevelModal.tsx
interface RegisterLevelModalProps {
  isOpen: boolean
  effect: RegisterEffect | null
  onConfirm: (level: number, partyMembers?: number) => void
  onCancel: () => void
}

export default function RegisterLevelModal({ 
  isOpen, 
  effect, 
  onConfirm, 
  onCancel 
}: RegisterLevelModalProps) {
  const [level, setLevel] = useState(effect?.level || 1)
  const [partyMembers, setPartyMembers] = useState(effect?.partyMembers || 1)
  
  const isFatefulCompanionship = effect?.id === 'fatefulCompanionship'

  return (
    <Modal isOpen={isOpen} onClose={onCancel}>
      <div className="p-6 space-y-4">
        <h3 className="text-lg font-medium">{effect?.name} - レベル設定</h3>
        
        {/* レベル入力 */}
        <div>
          <label className="block text-sm font-medium mb-1">レベル</label>
          <input
            type="number"
            min="1"
            max={effect?.maxLevel || 30}
            value={level}
            onChange={(e) => setLevel(Number(e.target.value))}
            className="w-full px-3 py-2 border border-gray-300 rounded-md"
          />
        </div>
        
        {/* 運命共同体専用：パーティメンバー数 */}
        {isFatefulCompanionship && (
          <div>
            <label className="block text-sm font-medium mb-1">
              自分以外のパーティメンバー数
            </label>
            <input
              type="number"
              min="1"
              max="3"
              value={partyMembers}
              onChange={(e) => setPartyMembers(Number(e.target.value))}
              className="w-full px-3 py-2 border border-gray-300 rounded-md"
            />
          </div>
        )}
        
        {/* 確定・キャンセルボタン */}
        <div className="flex justify-end space-x-2">
          <button 
            onClick={onCancel}
            className="px-4 py-2 text-gray-600 border border-gray-300 rounded-md"
          >
            キャンセル
          </button>
          <button 
            onClick={() => onConfirm(level, isFatefulCompanionship ? partyMembers : undefined)}
            className="px-4 py-2 bg-blue-500 text-white rounded-md"
          >
            確定
          </button>
        </div>
      </div>
    </Modal>
  )
}
```

### 12.5 状態管理統合

**CalculatorStore統合**:
```typescript
interface CalculatorStore {
  data: {
    // 既存データ...
    register: RegisterFormData
  }
  
  // レジスタ他関連アクション
  updateRegisterEffect: (effectId: string, enabled: boolean) => void
  updateRegisterLevel: (effectId: string, level: number, partyMembers?: number) => void
  resetRegisterData: () => void
}
```

### 12.6 プロパティ変換システム

**効果からプロパティへの変換**:
```typescript
// registerEffectConverter.ts
export function convertRegisterEffectsToProperties(
  registerData: RegisterFormData
): Partial<EquipmentProperties> {
  const properties: Partial<EquipmentProperties> = {}
  
  // 物理攻撃アップ
  if (registerData.physicalAttackUp.enabled) {
    properties.ATK = (properties.ATK || 0) + registerData.physicalAttackUp.level
  }
  
  // 魔法攻撃アップ  
  if (registerData.magicalAttackUp.enabled) {
    properties.MATK = (properties.MATK || 0) + registerData.magicalAttackUp.level
  }
  
  // 運命共同体（特殊計算）
  if (registerData.fatefulCompanionship.enabled) {
    const baseBonus = 5  // レベル1固定効果
    const partyBonus = registerData.fatefulCompanionship.partyMembers * 3
    const totalBonus = baseBonus + partyBonus
    
    properties.ATK = (properties.ATK || 0) + totalBonus
    properties.MATK = (properties.MATK || 0) + totalBonus
  }
  
  // その他の効果も同様に変換...
  
  return properties
}
```

### 12.7 データ永続化

**LocalStorage統合**:
```typescript
// セーブデータ構造に追加
interface SaveData {
  // 既存フィールド...
  register: RegisterFormData
}

// 初期データ
export const createInitialRegisterData = (): RegisterFormData => ({
  physicalAttackUp: {
    id: 'physicalAttackUp',
    name: '物理攻撃アップ',
    type: 'registlet',
    enabled: false,
    level: 30,        // 最大値で初期化
    maxLevel: 30
  },
  // 他の項目も同様に最大値で初期化...
})
```